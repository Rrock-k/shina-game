<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <title>Карта Шины</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    canvas {
      display: block;
      width: 1200px;
      height: 800px;
      border: 2px solid #444;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
</head>

<body>
  <script>
    const CONFIG = {
      WORLD_WIDTH: 3000,
      WORLD_HEIGHT: 2000,
      GRID_STEP: 100,
      ROAD_SPACING: 400,
      ROAD_WIDTH: 48,
      ROAD_LINE_WIDTH: 12,
      DASH_LENGTH: 60,
      DASH_GAP: 60,
      COLORS: {
        grid: 0xffffff,
        border: 0xff0000,
        road: 0x666666,
        roadLine: 0xffffff,
        house: 0xffe0e0,
        work: 0xe0e8ff,
        box: 0xfff2cc,
        relatives: 0xe0ffe0,
        institute: 0xd0f0ff,
      },
      ZONES: {
        house: { type: 'rect', x: 300, y: 150, w: 220, h: 160, label: 'Дом Шины' },
        relatives: { type: 'rect', x: 1280, y: 180, w: 440, h: 440, label: 'Родственники' },
        work: { type: 'rect', x: 1100, y: 1100, w: 260, h: 180, label: 'Работа' },
        box: { type: 'rect', x: 450, y: 1450, w: 200, h: 160, label: 'Бокс' },
        institute: { type: 'circle', x: 1700, y: 1600, r: 100, label: 'Институт', alpha: 0.6 },
      },
      TRAFFIC_LIGHTS: [
        { x: 400, y: 400 },
        { x: 1600, y: 400 },
        { x: 1600, y: 1600 },
        { x: 400, y: 1600 }
      ],
      CAR_PATH: [
        { x: 400, y: 400 },
        { x: 400, y: 1600 },
        { x: 1600, y: 1600 },
        { x: 1600, y: 400 }
      ],
      BASE_FONT: 24
    };

    const CAR_SPEED = 2;

    // globals
    let app, world, gridLayer, roadsLayer, zonesLayer, labelsLayer, decorLayer, borderLayer, uiLayer, car;
    let carPath = [], carSegment = 0, carProgress = 0;
    let avatar;

    setupApp();
    setupWorld();
    createCar();
    layout();
    window.addEventListener('resize', () => {
      layout();
    });

    function setupApp () {
      app = new PIXI.Application({
        width: 1200,
        height: 800,
        autoDensity: true,
        resolution: window.devicePixelRatio || 1,
        backgroundColor: 0x3a6f3e
      });
      document.body.appendChild(app.view);
    }

    function setupWorld () {
      world = new PIXI.Container();
      app.stage.addChild(world);

      gridLayer = new PIXI.Container();
      roadsLayer = new PIXI.Container();
      zonesLayer = new PIXI.Container();
      labelsLayer = new PIXI.Container();
      decorLayer = new PIXI.Container();
      borderLayer = new PIXI.Container();

      world.addChild(gridLayer, roadsLayer, zonesLayer, labelsLayer, decorLayer, borderLayer);

      drawGrid(gridLayer);
      drawRoads(roadsLayer);
      drawZones(zonesLayer);
      placeLabels(labelsLayer);
      drawTrafficLights(decorLayer);
      drawAlina(decorLayer);
      drawWorldBorder(borderLayer);

      uiLayer = new PIXI.Container();
      app.stage.addChild(uiLayer);
      const title = new PIXI.Text('Карта города (наблюдатель)', {
        fontFamily: 'sans-serif',
        fontSize: 20,
        fill: 0xffffff,
        stroke: 0x000000,
        strokeThickness: 3
      });
      title.position.set(10, 10);
      uiLayer.addChild(title);
    }

    function drawGrid (layer) {
      const g = new PIXI.Graphics();
      g.lineStyle(1, CONFIG.COLORS.grid, 0.15);
      for (let i = 0; i <= CONFIG.WORLD_WIDTH; i += CONFIG.GRID_STEP) {
        g.moveTo(i, 0); g.lineTo(i, CONFIG.WORLD_HEIGHT);
      }
      for (let i = 0; i <= CONFIG.WORLD_HEIGHT; i += CONFIG.GRID_STEP) {
        g.moveTo(0, i); g.lineTo(CONFIG.WORLD_WIDTH, i);
      }
      layer.addChild(g);
    }

    function drawWorldBorder (layer) {
      const g = new PIXI.Graphics();
      g.lineStyle(8, CONFIG.COLORS.border, 1.0);
      g.drawRect(0, 0, CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT);
      layer.addChild(g);
    }

    function drawZones (layer) {
      const zones = CONFIG.ZONES;
      for (const key in zones) {
        const z = zones[key];
        const g = new PIXI.Graphics();
        g.lineStyle(2, 0x333333, 0.8);
        if (z.type === 'rect') {
          g.beginFill(CONFIG.COLORS[key], 0.8);
          g.drawRect(z.x, z.y, z.w, z.h);
          g.endFill();
        } else if (z.type === 'circle') {
          g.beginFill(CONFIG.COLORS[key], z.alpha || 0.4);
          g.drawCircle(z.x, z.y, z.r);
          g.endFill();
        }
        layer.addChild(g);
      }
    }

    function drawRoads (layer) {
      const step = CONFIG.ROAD_SPACING;

      // Определяем самую правую позицию для вертикальных дорог
      let maxVerticalPos = 0;
      for (let pos = 0; pos <= CONFIG.WORLD_WIDTH; pos += step) {
        maxVerticalPos = pos;
      }

      // Горизонтальные дороги (исключаем крайние позиции по верху и низу)
      for (let pos = step; pos <= CONFIG.WORLD_HEIGHT - step; pos += step) {
        const h = [{ x: step, y: pos }, { x: maxVerticalPos, y: pos }];
        const roadH = new PIXI.Graphics();
        roadH.lineStyle(CONFIG.ROAD_WIDTH, CONFIG.COLORS.road, 1);
        roadH.moveTo(h[0].x, h[0].y);
        roadH.lineTo(h[1].x, h[1].y);
        layer.addChild(roadH);
        const dashH = new PIXI.Graphics();
        dashH.lineStyle(CONFIG.ROAD_LINE_WIDTH, CONFIG.COLORS.roadLine, 1);
        drawDashedPath(dashH, h, CONFIG.DASH_LENGTH, CONFIG.DASH_GAP);
        layer.addChild(dashH);
      }

      // Вертикальные дороги (исключаем крайнюю левую позицию)
      for (let pos = step; pos <= CONFIG.WORLD_WIDTH; pos += step) {
        let v;
        // Самая правая дорога (трасса) - продолжается за пределы карты
        if (pos === maxVerticalPos) {
          v = [{ x: pos, y: 0 }, { x: pos, y: CONFIG.WORLD_HEIGHT }];
        } else {
          // Остальные вертикальные дороги ограничены границами карты
          v = [{ x: pos, y: step }, { x: pos, y: CONFIG.WORLD_HEIGHT - step }];
        }
        const roadV = new PIXI.Graphics();
        roadV.lineStyle(CONFIG.ROAD_WIDTH, CONFIG.COLORS.road, 1);
        roadV.moveTo(v[0].x, v[0].y);
        roadV.lineTo(v[1].x, v[1].y);
        layer.addChild(roadV);
        const dashV = new PIXI.Graphics();
        dashV.lineStyle(CONFIG.ROAD_LINE_WIDTH, CONFIG.COLORS.roadLine, 1);
        drawDashedPath(dashV, v, CONFIG.DASH_LENGTH, CONFIG.DASH_GAP);
        layer.addChild(dashV);
      }
    }

    function drawDashedPath (g, points, dash, gap) {
      for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i], p2 = points[i + 1];
        const dx = p2.x - p1.x, dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        let t = 0;
        while (t <= len) {
          const from = t;
          const to = Math.min(t + dash, len);
          const sx = p1.x + dx * (from / len);
          const sy = p1.y + dy * (from / len);
          const ex = p1.x + dx * (to / len);
          const ey = p1.y + dy * (to / len);
          g.moveTo(sx, sy);
          g.lineTo(ex, ey);
          t += dash + gap;
        }
      }
    }

    function drawTrafficLights (layer) {
      CONFIG.TRAFFIC_LIGHTS.forEach(pos => {
        const c = new PIXI.Container();
        c.position.set(pos.x, pos.y);
        const pole = new PIXI.Graphics();
        pole.beginFill(0x555555).drawRect(-3, -20, 6, 40).endFill();
        const box = new PIXI.Graphics();
        box.beginFill(0x111111).drawRect(-8, -32, 16, 28).endFill();
        const red = new PIXI.Graphics(); red.beginFill(0xff0000).drawCircle(0, -26, 5).endFill();
        const yellow = new PIXI.Graphics(); yellow.beginFill(0xffff00).drawCircle(0, -16, 5).endFill();
        const green = new PIXI.Graphics(); green.beginFill(0x00ff00).drawCircle(0, -6, 5).endFill();
        c.addChild(pole, box, red, yellow, green);
        layer.addChild(c);
      });
    }

    function drawAlina (layer) {
      const house = CONFIG.ZONES.house;
      const container = new PIXI.Container();
      container.position.set(house.x + house.w - 40, house.y + house.h - 40);
      const circle = new PIXI.Graphics();
      circle.beginFill(0xffffff).drawCircle(0, 0, 15).endFill();
      const text = new PIXI.Text('A', {
        fontFamily: 'sans-serif',
        fontSize: 20,
        fill: 0x000000,
        stroke: 0xffffff,
        strokeThickness: 2
      });
      text.anchor.set(0.5);
      container.addChild(circle, text);
      layer.addChild(container);
    }

    function placeLabels (layer) {
      for (const key in CONFIG.ZONES) {
        const z = CONFIG.ZONES[key];
        let x, y;
        if (z.type === 'rect') {
          x = z.x + z.w / 2;
          y = z.y + z.h / 2;
        } else {
          x = z.x;
          y = z.y;
        }
        const text = new PIXI.Text(z.label, {
          fontFamily: 'sans-serif',
          fontSize: CONFIG.BASE_FONT,
          fill: 0xffffff,
          stroke: 0x000000,
          strokeThickness: 4
        });
        text.anchor.set(0.5);
        text.position.set(x, y);
        layer.addChild(text);
      }
    }

    function layout () {
      const w = 1200; // фиксированная ширина канваса
      const h = 800;  // фиксированная высота канваса
      const scale = Math.min(w / CONFIG.WORLD_WIDTH, h / CONFIG.WORLD_HEIGHT);
      world.scale.set(scale);
      world.position.set(
        (w - CONFIG.WORLD_WIDTH * scale) / 2,
        (h - CONFIG.WORLD_HEIGHT * scale) / 2
      );
      labelsLayer.children.forEach(label => {
        label.scale.set(1 / scale);
      });
    }

    function buildCarPath () {
      return CONFIG.CAR_PATH;
    }

    function createCar () {
      carPath = buildCarPath();
      car = new PIXI.Container();

      const body = new PIXI.Graphics();
      body.beginFill(0xff8800).drawRect(-60, -30, 120, 60).endFill();
      car.addChild(body);

      avatar = PIXI.Sprite.from('shina.jpeg');
      avatar.anchor.set(0.5);
      avatar.width = 60;
      avatar.height = 60;
      car.addChild(avatar);
      car.position.set(carPath[0].x, carPath[0].y);
      decorLayer.addChild(car);
      app.ticker.add(updateCar);
    }

    function updateCar (delta) {
      const speed = CAR_SPEED * delta;
      let p1 = carPath[carSegment];
      let p2 = carPath[(carSegment + 1) % carPath.length];
      let dx = p2.x - p1.x;
      let dy = p2.y - p1.y;
      let segLen = Math.hypot(dx, dy);
      carProgress += speed;
      while (carProgress > segLen) {
        carProgress -= segLen;
        carSegment = (carSegment + 1) % carPath.length;
        p1 = carPath[carSegment];
        p2 = carPath[(carSegment + 1) % carPath.length];
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        segLen = Math.hypot(dx, dy);
      }
      const t = carProgress / segLen;
      car.position.set(p1.x + dx * t, p1.y + dy * t);
      car.rotation = Math.atan2(dy, dx);
      avatar.rotation = -car.rotation;
    }
  </script>
</body>

</html>
