<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>–ö–∞—Ä—Ç–∞ –®–∏–Ω—ã</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #222;
      overflow: auto;
      touch-action: pan-x pan-y;
      -webkit-overflow-scrolling: touch;
    }

    canvas {
      display: block;
      width: 1200px;
      height: 800px;
      border: 2px solid #444;
      margin: 0 auto;
      touch-action: none;
    }

    /* –°—Ç–∏–ª–∏ –¥–ª—è –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è */
    body {
      overflow: auto;
      position: relative;
    }

    canvas {
      min-width: 1200px;
      min-height: 800px;
      margin: 0;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
</head>

<body>
  <script type="module">
    import { initTrafficLightsForIntersection, getDirectionForSegment, Direction, TrafficLightCoordinator } from './trafficLights.js';
    import { CarTrafficController } from './carTrafficControl.js';
    import { PanningController } from './panning.js';
    const CONFIG = {
      WORLD_WIDTH: 3000,
      WORLD_HEIGHT: 2000,
      GRID_STEP: 100,
      ROAD_SPACING_H: 450,  // —à–∞–≥ –º–µ–∂–¥—É –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–º–∏ –¥–æ—Ä–æ–≥–∞–º–∏ (7 –¥–æ—Ä–æ–≥)
      ROAD_SPACING_V: 567,  // —à–∞–≥ –º–µ–∂–¥—É –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–º–∏ –¥–æ—Ä–æ–≥–∞–º–∏ (4 –¥–æ—Ä–æ–≥–∏)
      ROAD_MARGIN: 150,
      ROAD_WIDTH: 48,
      ROAD_LINE_WIDTH: 12,
      DASH_LENGTH: 60,
      DASH_GAP: 60,
      COLORS: {
        grid: 0xffffff,
        border: 0xff0000,
        road: 0x666666,
        roadLine: 0xffffff,
        house: 0xffe0e0,
        work: 0xe0e8ff,
        box: 0xfff2cc,
        relatives: 0xe0ffe0,
        institute: 0xd0f0ff,
        lotFill: 0xf1e9d2,
        lotBorder: 0x777777,
      },
      LOTS: {
        SLOTS_PER_BLOCK: 6,
        GAP: 10,
        PADDING: 20,
        MAX_MULTI_SLOT: 3,
        MIN_LOT_HEIGHT: 60,
        FILL_ALPHA: 0.9
      },
      ZONE_LAYOUT: {
        // –∏–Ω–¥–µ–∫—Å—ã –±–ª–æ–∫–æ–≤: 0..(–∫–æ–ª-–≤–æ-1) —Å–ª–µ–≤–∞-–Ω–∞–ø—Ä–∞–≤–æ –∏ —Å–≤–µ—Ä—Ö—É-–≤–Ω–∏–∑
        house: { block: { i: 0, j: 0 }, cells: [[0, 0]] },           // 1x1
        relatives: { block: { i: 5, j: 0 }, cells: [[1, 0]] },       // 1x1
        work: { block: { i: 3, j: 1 }, cells: [[0, 1], [1, 1]] },    // 2x1 (–¥–≤–µ –∫–æ–ª–æ–Ω–∫–∏ –≤ –æ–¥–Ω–æ–º —Ä—è–¥—É)
        box: { block: { i: 1, j: 2 }, cells: [[0, 1], [0, 2]] },     // 1x2 (–¥–≤–µ —Å—Ç—Ä–æ–∫–∏ –≤ –æ–¥–Ω–æ–º —Å—Ç–æ–ª–±—Ü–µ)
        institute: { block: { i: 5, j: 2 }, cells: [[0, 0], [1, 0], [1, 1]] } // –ì-–æ–±—Ä–∞–∑–Ω–æ 3 —è—á–µ–π–∫–∏
      },
      ZONES: {
        house: { type: 'rect', x: 200, y: 200, w: 440, h: 750, label: '–î–æ–º –®–∏–Ω—ã' },
        relatives: { type: 'rect', x: 1300, y: 200, w: 440, h: 750, label: '–†–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏' },
        work: { type: 'rect', x: 1840, y: 1100, w: 440, h: 700, label: '–†–∞–±–æ—Ç–∞' },
        box: { type: 'rect', x: 200, y: 1100, w: 440, h: 700, label: '–ë–æ–∫—Å' },
        institute: { type: 'circle', x: 2550, y: 1425, r: 200, label: '–ò–Ω—Å—Ç–∏—Ç—É—Ç', alpha: 0.6 },
      },
      TRAFFIC_LIGHTS: [
        { x: 600, y: 1283 },
        { x: 1050, y: 1283 },
        { x: 1500, y: 1283 },
        { x: 1950, y: 1283 }
      ],
      CAR_PATH: [
        { x: 600, y: 1283 },
        { x: 1050, y: 1283 },
        { x: 1500, y: 1283 },
        { x: 1950, y: 1283 }
      ],
      BASE_FONT: 32
    };

    const CAR_SPEED = 11.7;

    // globals
    let app, world, gridLayer, roadsLayer, lotsLayer, zonesLayer, labelsLayer, intersectionsLayer, decorLayer, trafficLightsLayer, borderLayer, uiLayer, car;
    let carPath = [], carSegment = 0, carProgress = 0;
    let avatar;
    let horizontalRoadYs = [], verticalRoadXs = [];
    let hoverLabel;
    let carTrafficController;
    let buildingAvatars = new Map(); // –∫–∞—Ä—Ç–∞ –∑–¥–∞–Ω–∏–π -> –º–∞–ª–µ–Ω—å–∫–∏–µ –∞–≤–∞—Ç–∞—Ä–∫–∏

    // –ì–µ–æ–º–µ—Ç—Ä–∏—è –∑–æ–Ω, –≤—ã—á–∏—Å–ª–µ–Ω–Ω–∞—è –ø—Ä–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–µ
    const zoneGeometry = new Map(); // key -> { center:{x,y}, bounds:{x,y,w,h} | {x,y,r}, type }

    // –°–∏—Å—Ç–µ–º–∞ –º–∞—Ä—à—Ä—É—Ç–æ–≤ –∏ –≤—Ä–µ–º–µ–Ω–∏
    let gameTime = { hours: 8, minutes: 0 }; // –Ω–∞—á–∏–Ω–∞–µ–º —Å 8:00
    let timeSpeed = 60; // 1 —Ä–µ–∞–ª—å–Ω–∞—è —Å–µ–∫—É–Ω–¥–∞ = 1 –∏–≥—Ä–æ–≤–∞—è –º–∏–Ω—É—Ç–∞
    let lastTimeUpdate = Date.now();
    let clockDisplay;
    let routeDisplay;
    let currentRouteIndex = 0;
    let stayTimer = 0; // —Ç–∞–π–º–µ—Ä –ø—Ä–µ–±—ã–≤–∞–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–º –º–µ—Å—Ç–µ
    let isAtDestination = false; // –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –º–∞—à–∏–Ω–∞ –≤ –ø—É–Ω–∫—Ç–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ —Å–≤–µ—Ç–æ—Ñ–æ—Ä–æ–≤ –ø–æ –∫–ª—é—á—É –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–∞
    const intersectionKeyToTL = new Map();
    // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä –∑–µ–ª–µ–Ω–æ–π –≤–æ–ª–Ω—ã —Å–≤–µ—Ç–æ—Ñ–æ—Ä–æ–≤
    const trafficCoordinator = new TrafficLightCoordinator(45); // —Å–∫–æ—Ä–æ—Å—Ç—å –º–∞—à–∏–Ω ~45 –∫–º/—á

    // üö¶ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –°–í–ï–¢–û–§–û–†–û–í üö¶
    // –ú–∞—Å—Å–∏–≤ –±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–æ–≤, –≥–¥–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å–≤–µ—Ç–æ—Ñ–æ—Ä—ã
    // –§–æ—Ä–º–∞—Ç: 'A1', 'B2', 'C3' –∏ —Ç.–¥. (–±—É–∫–≤–∞ = —Å—Ç–æ–ª–±–µ—Ü –¥–æ—Ä–æ–≥–∏, —Ü–∏—Ñ—Ä–∞ = —Ä—è–¥ –¥–æ—Ä–æ–≥–∏)
    // –ú–æ–∂–Ω–æ –ª–µ–≥–∫–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç –º–∞—Å—Å–∏–≤ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è —Å–≤–µ—Ç–æ—Ñ–æ—Ä–æ–≤!
    const TRAFFIC_LIGHTS_CONFIG = [
      'A2', 'A3',        // –ª–µ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü (–≤—ä–µ–∑–¥ –≤ –≥–æ—Ä–æ–¥)
      'B2', 'B4',        // –≤—Ç–æ—Ä–æ–π —Å—Ç–æ–ª–±–µ—Ü  
      'C1', 'C3',        // —Ç—Ä–µ—Ç–∏–π —Å—Ç–æ–ª–±–µ—Ü
      'D2', 'D4',        // —á–µ—Ç–≤–µ—Ä—Ç—ã–π —Å—Ç–æ–ª–±–µ—Ü
      'E1', 'E3',        // –ø—è—Ç—ã–π —Å—Ç–æ–ª–±–µ—Ü
      'F2', 'F4',        // —à–µ—Å—Ç–æ–π —Å—Ç–æ–ª–±–µ—Ü
      'G1', 'G2', 'G3', 'G4' // –ø—Ä–∞–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü (–≤—ã–µ–∑–¥ –∏–∑ –≥–æ—Ä–æ–¥–∞) - –≤—Å–µ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–∏
    ];

    // üöõ –ú–ê–†–®–†–£–¢ –®–ò–ù–´ üöõ
    // –ú–∞—Å—Å–∏–≤ —Å –º–∞—Ä—à—Ä—É—Ç–æ–º: –º–µ—Å—Ç–æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∏ –≤—Ä–µ–º—è –ø—Ä–µ–±—ã–≤–∞–Ω–∏—è (–≤ –∏–≥—Ä–æ–≤—ã—Ö —á–∞—Å–∞—Ö)
    // –ü–æ–∑–∏—Ü–∏–∏ –≤—ã—á–∏—Å–ª—è—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∏–∑ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∑–æ–Ω, –∞ –ù–ï –∑–∞—Ö–∞—Ä–¥–∫–æ–∂–µ–Ω—ã
    const ROUTE_SCHEDULE = [
      { location: 'house', name: '–î–æ–º', stayHours: 2 },
      { location: 'institute', name: '–ò–Ω—Å—Ç–∏—Ç—É—Ç', stayHours: 2 },
      { location: 'work', name: '–†–∞–±–æ—Ç–∞', stayHours: 5 },
      { location: 'relatives', name: '–†–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏', stayHours: 1.5 },
      { location: 'box', name: '–ë–æ–∫—Å', stayHours: 1 },
    ];

    setupApp();
    setupWorld();
    createCar();
    layout();
    window.addEventListener('resize', () => {
      // –£–±–∏—Ä–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ canvas - –æ—Å—Ç–∞–≤–ª—è–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä
      layout();
    });



    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ –±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ –∏–Ω–¥–µ–∫—Å—ã
    function parseIntersectionCoordinate (coord) {
      const letter = coord.charAt(0);
      const number = parseInt(coord.slice(1));
      const i = letter.charCodeAt(0) - 65; // A=0, B=1, C=2...
      const j = number - 1; // 1=0, 2=1, 3=2...
      return { i, j };
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ —Å–≤–µ—Ç–æ—Ñ–æ—Ä –Ω–∞ –¥–∞–Ω–Ω–æ–º –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–µ
    function shouldHaveTrafficLight (i, j) {
      const coord = String.fromCharCode(65 + i) + (j + 1);
      return TRAFFIC_LIGHTS_CONFIG.includes(coord);
    }

    function setupApp () {
      app = new PIXI.Application({
        width: 1200,
        height: 800,
        autoDensity: true,
        resolution: window.devicePixelRatio || 1,
        backgroundColor: 0x3a6f3e
      });
      document.body.appendChild(app.view);
      // –í–∫–ª—é—á–∞–µ–º —Å–∏—Å—Ç–µ–º—É —Å–æ–±—ã—Ç–∏–π –¥–ª—è –≤—Å–µ–π —Å—Ü–µ–Ω—ã
      app.stage.eventMode = 'static';
      app.stage.hitArea = new PIXI.Rectangle(0, 0, 1200, 800);
    }

    function setupWorld () {
      world = new PIXI.Container();
      app.stage.addChild(world);

      gridLayer = new PIXI.Container();
      roadsLayer = new PIXI.Container();
      lotsLayer = new PIXI.Container();
      zonesLayer = new PIXI.Container();
      labelsLayer = new PIXI.Container();
      intersectionsLayer = new PIXI.Container();
      decorLayer = new PIXI.Container();
      trafficLightsLayer = new PIXI.Container(); // —Å–ª–æ–π –¥–ª—è —Å–≤–µ—Ç–æ—Ñ–æ—Ä–æ–≤ (–ø–æ–≤–µ—Ä—Ö –º–∞—à–∏–Ω)
      borderLayer = new PIXI.Container();

      world.addChild(gridLayer, roadsLayer, intersectionsLayer, lotsLayer, zonesLayer, labelsLayer, decorLayer, trafficLightsLayer, borderLayer);

      drawGrid(gridLayer);
      drawRoads(roadsLayer);
      createIntersections(intersectionsLayer);
      drawLots(lotsLayer);
      drawZones(zonesLayer);
      // placeLabels(labelsLayer);
      // –°–≤–µ—Ç–æ—Ñ–æ—Ä—ã —Ç–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞—é—Ç—Å—è –Ω–∞ –∫–∞–∂–¥–æ–º –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–µ (–≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Å–ª–æ–µ –ø–æ–≤–µ—Ä—Ö –º–∞—à–∏–Ω)
      createTrafficLightsForAllIntersections(trafficLightsLayer);
      // drawAlina(decorLayer);
      drawWorldBorder(borderLayer);

      uiLayer = new PIXI.Container();
      app.stage.addChild(uiLayer);
      const title = new PIXI.Text('–ö–∞—Ä—Ç–∞ –≥–æ—Ä–æ–¥–∞ (–Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—å)', {
        fontFamily: 'sans-serif',
        fontSize: 20,
        fill: 0xffffff,
        stroke: 0x000000,
        strokeThickness: 3
      });
      title.position.set(10, 10);
      uiLayer.addChild(title);

      // –ò–≥—Ä–æ–≤—ã–µ —á–∞—Å—ã
      clockDisplay = new PIXI.Text('08:00', {
        fontFamily: 'sans-serif',
        fontSize: 32,
        fill: 0xffffff,
        stroke: 0x000000,
        strokeThickness: 4
      });
      clockDisplay.position.set(10, 45);
      uiLayer.addChild(clockDisplay);

      // –î–∏—Å–ø–ª–µ–π —Ç–µ–∫—É—â–µ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞
      routeDisplay = new PIXI.Text('–ú–∞—Ä—à—Ä—É—Ç: –î–æ–º (2—á)', {
        fontFamily: 'sans-serif',
        fontSize: 18,
        fill: 0xffff00,
        stroke: 0x000000,
        strokeThickness: 3
      });
      routeDisplay.position.set(10, 85);
      uiLayer.addChild(routeDisplay);

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∏—Å–ø–ª–µ–π –º–∞—Ä—à—Ä—É—Ç–∞
      updateRouteDisplay();
      // –õ—ë–≥–∫–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞, —á—Ç–æ–±—ã –∑–æ–Ω–∞ —É—Å–ø–µ–ª–∞ –æ—Ç—Ä–∏—Å–æ–≤–∞—Ç—å—Å—è, –∑–∞—Ç–µ–º –ø–æ—Å—Ç—Ä–æ–∏–º –ø–µ—Ä–≤—ã–π –ø—É—Ç—å
      setTimeout(() => {
        // –ø–µ—Ä–µ—Å—Ç—Ä–æ–∏–º –ø—É—Ç—å, –∫–æ–≥–¥–∞ –≥–µ–æ–º–µ—Ç—Ä–∏—è –∑–æ–Ω —É–∂–µ –∏–∑–≤–µ—Å—Ç–Ω–∞
        if (car) {
          carPath = buildCarPath();
        }
      }, 0);
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∏—Å–ø–ª–µ—è –º–∞—Ä—à—Ä—É—Ç–∞
    function updateRouteDisplay () {
      if (!routeDisplay) return; // –∑–∞—â–∏—Ç–∞ –æ—Ç –≤—ã–∑–æ–≤–∞ –¥–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
      const currentDest = ROUTE_SCHEDULE[currentRouteIndex];
      if (isAtDestination) {
        const remainingHours = Math.max(0, stayTimer).toFixed(1);
        routeDisplay.text = `–í –ø—É–Ω–∫—Ç–µ: ${currentDest.name} (${remainingHours}—á)`;
      } else {
        routeDisplay.text = `–ï–¥–µ–º –≤: ${currentDest.name} (${currentDest.stayHours}—á)`;
      }
    }

    function getRoadPositions () {
      const margin = CONFIG.ROAD_MARGIN;
      const horizontalPositions = [];
      const verticalPositions = [];
      const availableHeight = CONFIG.WORLD_HEIGHT - 2 * margin;
      for (let i = 0; i < 4; i++) {
        const y = margin + (availableHeight / (4 - 1)) * i;
        horizontalPositions.push(y);
      }
      const availableWidth = CONFIG.WORLD_WIDTH - 2 * margin;
      for (let i = 0; i < 7; i++) {
        const x = margin + (availableWidth / (7 - 1)) * i;
        verticalPositions.push(x);
      }
      const maxVerticalPos = verticalPositions[verticalPositions.length - 1];

      // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–∑–∏—Ü–∏—è—Ö –¥–æ—Ä–æ–≥
      console.log('Horizontal roads (Y coordinates):', horizontalPositions);
      console.log('Vertical roads (X coordinates):', verticalPositions);

      return { horizontalPositions, verticalPositions, maxVerticalPos };
    }

    function drawGrid (layer) {
      const g = new PIXI.Graphics();
      g.lineStyle(1, CONFIG.COLORS.grid, 0.15);
      for (let i = 0; i <= CONFIG.WORLD_WIDTH; i += CONFIG.GRID_STEP) {
        g.moveTo(i, 0); g.lineTo(i, CONFIG.WORLD_HEIGHT);
      }
      for (let i = 0; i <= CONFIG.WORLD_HEIGHT; i += CONFIG.GRID_STEP) {
        g.moveTo(0, i); g.lineTo(CONFIG.WORLD_WIDTH, i);
      }
      layer.addChild(g);
    }

    function drawWorldBorder (layer) {
      const g = new PIXI.Graphics();
      g.lineStyle(8, CONFIG.COLORS.border, 1.0, 0);
      g.drawRect(0, 0, CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT);
      layer.addChild(g);
    }

    function randInt (min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateBuildingSlots (maxSlots) {
      const sizes = [];
      const target = randInt(Math.max(3, Math.floor(maxSlots / 2)), maxSlots);
      let used = 0;
      while (used < target) {
        const remaining = target - used;
        const maxTake = Math.min(remaining, CONFIG.LOTS.MAX_MULTI_SLOT);
        const roll = Math.random();
        let take = 1;
        if (maxTake >= 3 && roll < 0.18) take = 3;
        else if (maxTake >= 2 && roll < 0.55) take = 2;
        sizes.push(take);
        used += take;
      }
      return sizes;
    }

    function drawLots (layer) {
      if (!horizontalRoadYs.length || !verticalRoadXs.length) return;
      const roadHalf = CONFIG.ROAD_WIDTH / 2;
      const cols = 2; // –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
      const rows = 3; // –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
      const gap = CONFIG.LOTS.GAP;
      const padding = CONFIG.LOTS.PADDING;

      for (let j = 0; j < horizontalRoadYs.length - 1; j++) {
        const yTop = horizontalRoadYs[j] + roadHalf;
        const yBottom = horizontalRoadYs[j + 1] - roadHalf;
        const blockHeight = Math.max(0, yBottom - yTop);
        const innerHeight = Math.max(0, blockHeight - padding * 2);
        if (innerHeight <= 0) continue;
        const totalGapsV = gap * (rows - 1);
        const lotHeight = (innerHeight - totalGapsV) / rows;

        for (let i = 0; i < verticalRoadXs.length - 1; i++) {
          const xLeft = verticalRoadXs[i] + roadHalf;
          const xRight = verticalRoadXs[i + 1] - roadHalf;
          const blockWidth = Math.max(0, xRight - xLeft);
          const innerWidth = Math.max(0, blockWidth - padding * 2);
          if (innerWidth <= 0) continue;
          const totalGapsH = gap * (cols - 1);
          const lotWidth = (innerWidth - totalGapsH) / cols;

          const startX = xLeft + padding;
          const startY = yTop + padding;

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const rx = startX + c * (lotWidth + gap);
              const ry = startY + r * (lotHeight + gap);
              const g = new PIXI.Graphics();
              g.lineStyle(1, CONFIG.COLORS.lotBorder, 0.9);
              g.beginFill(CONFIG.COLORS.lotFill, CONFIG.LOTS.FILL_ALPHA);
              g.drawRect(rx, ry, lotWidth, lotHeight);
              g.endFill();
              layer.addChild(g);
            }
          }
        }
      }
    }

    function drawZones (layer) {
      if (!horizontalRoadYs.length || !verticalRoadXs.length) return;
      const roadHalf = CONFIG.ROAD_WIDTH / 2;
      const cols = 2;
      const rows = 3;
      const gap = CONFIG.LOTS.GAP;
      const padding = CONFIG.LOTS.PADDING;

      const zoneLayout = CONFIG.ZONE_LAYOUT;
      const blocksAcross = verticalRoadXs.length - 1;
      const blocksDown = horizontalRoadYs.length - 1;

      function getBlockRect (bi, bj) {
        const yTop = horizontalRoadYs[bj] + roadHalf;
        const yBottom = horizontalRoadYs[bj + 1] - roadHalf;
        const xLeft = verticalRoadXs[bi] + roadHalf;
        const xRight = verticalRoadXs[bi + 1] - roadHalf;
        const blockWidth = Math.max(0, xRight - xLeft);
        const blockHeight = Math.max(0, yBottom - yTop);
        const innerWidth = Math.max(0, blockWidth - padding * 2);
        const innerHeight = Math.max(0, blockHeight - padding * 2);
        const totalGapsH = gap * (cols - 1);
        const totalGapsV = gap * (rows - 1);
        const lotWidth = (innerWidth - totalGapsH) / cols;
        const lotHeight = (innerHeight - totalGapsV) / rows;
        const startX = xLeft + padding;
        const startY = yTop + padding;
        return { startX, startY, lotWidth, lotHeight };
      }

      function drawZoneRect (x, y, w, h, color) {
        const g = new PIXI.Graphics();
        g.lineStyle(2, 0x333333, 0.9);
        g.beginFill(color, 1.0);
        g.drawRect(x, y, w, h);
        g.endFill();
        layer.addChild(g);
        return g;
      }

      function drawLabel (textValue, x, y, maxWidth) {
        const label = createWrappedLabel(textValue, CONFIG.BASE_FONT, Math.max(60, maxWidth * 0.9));
        label.position.set(x, y);
        layer.addChild(label);
      }

      function createWrappedLabel (textValue, fontSize, maxWidth) {
        const style = new PIXI.TextStyle({
          fontFamily: 'sans-serif',
          fontSize,
          fill: 0x000000,
          wordWrap: true,
          wordWrapWidth: maxWidth,
          breakWords: true,
          align: 'center',
          stroke: 0xffffff,
          strokeThickness: 4
        });
        const label = new PIXI.Text(textValue, style);
        label.anchor.set(0.5);
        return label;
      }

      function drawZoneFromCells (name, colorKey) {
        const conf = zoneLayout[name];
        if (!conf) return;
        const bi = conf.block.i;
        const bj = conf.block.j;
        if (bi < 0 || bj < 0 || bi >= blocksAcross || bj >= blocksDown) return;
        const { startX, startY, lotWidth, lotHeight } = getBlockRect(bi, bj);

        // –î–ª—è –∏–Ω—Å—Ç–∏—Ç—É—Ç–∞ —Ä–∏—Å—É–µ–º –ì-–æ–±—Ä–∞–∑–Ω–æ, –∏–Ω–∞—á–µ ‚Äî –æ–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
        if (name === 'institute') {
          // –Ø—á–µ–π–∫–∏ –ø–æ –∫–æ–Ω—Ñ–∏–≥—É –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö —Å–µ—Ç–∫–∏ –ª–æ—Ç–æ–≤
          const cells = conf.cells.map(([c, r]) => ({ c, r }));

          // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è: –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ —á–∏—Å–ª–∞
          const groupConsecutive = (arr) => {
            const groups = [];
            let start = null, prev = null;
            arr.forEach(v => {
              if (start === null) { start = v; prev = v; return; }
              if (v === prev + 1) { prev = v; return; }
              groups.push([start, prev]);
              start = v; prev = v;
            });
            if (start !== null) groups.push([start, prev]);
            return groups;
          };

          // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª–æ—Å—ã: –ø–æ –∫–∞–∂–¥–æ–º—É —Ä—è–¥—É –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ –∏ –ó–ê–ü–û–õ–ù–Ø–ï–ú –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –≥—ç–ø—ã
          const rowsUsed = Array.from(new Set(cells.map(x => x.r))).sort((a, b) => a - b);
          rowsUsed.forEach(r => {
            const colsHere = cells.filter(x => x.r === r).map(x => x.c).sort((a, b) => a - b);
            const seqs = groupConsecutive(colsHere);
            seqs.forEach(([c0, c1]) => {
              const x = startX + c0 * (lotWidth + gap);
              const y = startY + r * (lotHeight + gap);
              const w = (c1 - c0 + 1) * lotWidth + (c1 - c0) * gap; // –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –≥—ç–ø—ã
              const h = lotHeight;
              drawZoneRect(x, y, w, h, CONFIG.COLORS[colorKey]);
            });
          });

          // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ø–æ–ª–æ—Å—ã: –ø–æ –∫–∞–∂–¥–æ–π –∫–æ–ª–æ–Ω–∫–µ –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ —Ä—è–¥—ã –∏ –ó–ê–ü–û–õ–ù–Ø–ï–ú –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –≥—ç–ø—ã
          const colsUsed = Array.from(new Set(cells.map(x => x.c))).sort((a, b) => a - b);
          colsUsed.forEach(c => {
            const rowsHere = cells.filter(x => x.c === c).map(x => x.r).sort((a, b) => a - b);
            const seqs = groupConsecutive(rowsHere);
            seqs.forEach(([r0, r1]) => {
              const x = startX + c * (lotWidth + gap);
              const y = startY + r0 * (lotHeight + gap);
              const w = lotWidth;
              const h = (r1 - r0 + 1) * lotHeight + (r1 - r0) * gap; // –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –≥—ç–ø—ã
              drawZoneRect(x, y, w, h, CONFIG.COLORS[colorKey]);
            });
          });

          // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ì-–æ–±—Ä–∞–∑–Ω–æ–π –∑–æ–Ω—ã
          const minX = Math.min(...cells.map(({ c }) => startX + c * (lotWidth + gap)));
          const maxX = Math.max(...cells.map(({ c }) => startX + c * (lotWidth + gap) + lotWidth));
          const minY = Math.min(...cells.map(({ r }) => startY + r * (lotHeight + gap)));
          const maxY = Math.max(...cells.map(({ r }) => startY + r * (lotHeight + gap) + lotHeight));

          // –ü–æ–¥–ø–∏—Å—å –≤ —Ü–µ–Ω—Ç—Ä–µ —Ç—è–∂–µ—Å—Ç–∏ —Ñ–∏–≥—É—Ä—ã (—Å—Ä–µ–¥–Ω–µ–µ —Ü–µ–Ω—Ç—Ä–æ–≤ –∑–∞–Ω—è—Ç—ã—Ö —è—á–µ–µ–∫)
          const centers = cells.map(({ c, r }) => ({
            cx: startX + c * (lotWidth + gap) + lotWidth / 2,
            cy: startY + r * (lotHeight + gap) + lotHeight / 2
          }));
          const cgx = centers.reduce((s, p) => s + p.cx, 0) / centers.length;
          const cgy = centers.reduce((s, p) => s + p.cy, 0) / centers.length;
          // –®–∏—Ä–∏–Ω–∞ –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞: –æ—Ö–≤–∞—Ç—ã–≤–∞—é—â–∞—è —à–∏—Ä–∏–Ω–∞ —Ñ–∏–≥—É—Ä—ã
          drawLabel(CONFIG.ZONES[name].label, cgx, cgy, maxX - minX);

          // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é –∑–æ–Ω—ã (—Ü–µ–Ω—Ç—Ä –∏ bbox)
          const zoneData = {
            type: 'composite',
            center: { x: cgx, y: cgy },
            bounds: { x: minX, y: minY, w: maxX - minX, h: maxY - minY }
          };
          zoneGeometry.set(name, zoneData);
          console.log(`üèõÔ∏è –°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≥–µ–æ–º–µ—Ç—Ä–∏—è –∑–æ–Ω—ã ${name}:`, zoneData);
          return;
        }

        // –û–±—â–µ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–ª—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã—Ö –∑–æ–Ω
        let minC = Infinity, minR = Infinity, maxC = -Infinity, maxR = -Infinity;
        conf.cells.forEach(([c, r]) => {
          minC = Math.min(minC, c);
          minR = Math.min(minR, r);
          maxC = Math.max(maxC, c);
          maxR = Math.max(maxR, r);
        });
        const x = startX + minC * (lotWidth + gap);
        const y = startY + minR * (lotHeight + gap);
        const w = (maxC - minC + 1) * lotWidth + (maxC - minC) * gap;
        const h = (maxR - minR + 1) * lotHeight + (maxR - minR) * gap;
        drawZoneRect(x, y, w, h, CONFIG.COLORS[colorKey]);
        const cx = x + w / 2;
        const cy = y + h / 2;
        drawLabel(CONFIG.ZONES[name].label, cx, cy, w);
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é –∑–æ–Ω—ã
        zoneGeometry.set(name, { type: 'rect', center: { x: cx, y: cy }, bounds: { x, y, w, h } });
      }

      drawZoneFromCells('house', 'house');
      drawZoneFromCells('relatives', 'relatives');
      drawZoneFromCells('work', 'work');
      drawZoneFromCells('box', 'box');
      drawZoneFromCells('institute', 'institute');
      // –î–ª—è –∫—Ä—É–≥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ü–µ–Ω—Ç—Ä –∏ —Ä–∞–¥–∏—É—Å (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –±—ã–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ì-–æ–±—Ä–∞–∑–Ω–∞—è –∑–æ–Ω–∞)
      const inst = CONFIG.ZONES.institute;
      if (inst?.type === 'circle' && !zoneGeometry.has('institute')) {
        zoneGeometry.set('institute', { type: 'circle', center: { x: inst.x, y: inst.y }, bounds: { x: inst.x, y: inst.y, r: inst.r } });
      }
    }

    function drawRoads (layer) {
      const { horizontalPositions, verticalPositions, maxVerticalPos } = getRoadPositions();
      horizontalRoadYs = horizontalPositions;
      verticalRoadXs = verticalPositions;

      // –†–∏—Å—É–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –¥–æ—Ä–æ–≥–∏
      horizontalRoadYs.forEach(y => {
        const h = [{ x: verticalRoadXs[0], y: y }, { x: maxVerticalPos, y: y }];
        const roadH = new PIXI.Graphics();
        roadH.lineStyle(CONFIG.ROAD_WIDTH, CONFIG.COLORS.road, 1);
        roadH.moveTo(h[0].x, h[0].y);
        roadH.lineTo(h[1].x, h[1].y);
        layer.addChild(roadH);
        const dashH = new PIXI.Graphics();
        dashH.lineStyle(CONFIG.ROAD_LINE_WIDTH, CONFIG.COLORS.roadLine, 1);
        drawDashedPath(dashH, h, CONFIG.DASH_LENGTH, CONFIG.DASH_GAP);
        layer.addChild(dashH);
      });

      // –†–∏—Å—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –¥–æ—Ä–æ–≥–∏
      verticalRoadXs.forEach(x => {
        let v;
        if (x === maxVerticalPos) {
          v = [{ x: x, y: 0 }, { x: x, y: CONFIG.WORLD_HEIGHT }];
        } else {
          v = [{ x: x, y: horizontalRoadYs[0] }, { x: x, y: horizontalRoadYs[horizontalRoadYs.length - 1] }];
        }
        const roadV = new PIXI.Graphics();
        roadV.lineStyle(CONFIG.ROAD_WIDTH, CONFIG.COLORS.road, 1);
        roadV.moveTo(v[0].x, v[0].y);
        roadV.lineTo(v[1].x, v[1].y);
        layer.addChild(roadV);
        const dashV = new PIXI.Graphics();
        dashV.lineStyle(CONFIG.ROAD_LINE_WIDTH, CONFIG.COLORS.roadLine, 1);
        drawDashedPath(dashV, v, CONFIG.DASH_LENGTH, CONFIG.DASH_GAP);
        layer.addChild(dashV);
      });
    }

    function createIntersections (layer) {
      // –ü–æ–¥–ø–∏—Å—å –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
      if (!hoverLabel) {
        hoverLabel = new PIXI.Text('', {
          fontFamily: 'sans-serif',
          fontSize: CONFIG.BASE_FONT,
          fill: 0xffff66,
          stroke: 0x000000,
          strokeThickness: 4
        });
        hoverLabel.anchor.set(0.5, 1);
        hoverLabel.visible = false;
        labelsLayer.addChild(hoverLabel);
      }

      const hitRadius = 60;
      for (let j = 0; j < horizontalRoadYs.length; j++) {
        for (let i = 0; i < verticalRoadXs.length; i++) {
          const x = verticalRoadXs[i];
          const y = horizontalRoadYs[j];
          const labelText = String.fromCharCode(65 + i) + (j + 1);
          const g = new PIXI.Graphics();
          // –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π –∫—Ä—É–≥-—Ö–∏—Ç–±–æ–∫—Å + —è–≤–Ω–∞—è hitArea –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ–≥–æ —Ö–∏—Ç-—Ç–µ—Å—Ç–∞
          g.beginFill(0x000000, 0).drawCircle(0, 0, hitRadius).endFill();
          g.position.set(x, y);
          g.eventMode = 'static';
          g.cursor = 'pointer';
          g.hitArea = new PIXI.Circle(0, 0, hitRadius);
          const show = () => {
            hoverLabel.text = labelText;
            hoverLabel.position.set(x, y - 16);
            hoverLabel.visible = true;
          };
          const hide = () => {
            hoverLabel.visible = false;
          };
          g.on('pointerover', show);
          g.on('pointerout', hide);
          g.on('pointerenter', show);
          g.on('pointerleave', hide);
          layer.addChild(g);
        }
      }
    }

    function createTrafficLightsForAllIntersections (layer) {
      intersectionKeyToTL.clear();
      const { maxVerticalPos } = getRoadPositions();

      for (let j = 0; j < horizontalRoadYs.length; j++) {
        for (let i = 0; i < verticalRoadXs.length; i++) {
          const x = verticalRoadXs[i];
          const y = horizontalRoadYs[j];

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ–ª–∂–µ–Ω –ª–∏ –±—ã—Ç—å —Å–≤–µ—Ç–æ—Ñ–æ—Ä –Ω–∞ —ç—Ç–æ–º –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–µ
          if (!shouldHaveTrafficLight(i, j)) {
            continue; // –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ—Ç –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫
          }

          // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ –¥–æ—Ä–æ–≥–∏ –µ—Å—Ç—å –≤ –∫–∞–∂–¥–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
          const roadConnections = {
            north: j > 0 || (x === maxVerticalPos), // –¥–æ—Ä–æ–≥–∞ –Ω–∞ —Å–µ–≤–µ—Ä: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä—è–¥ –ò–õ–ò –ø—Ä–∞–≤–∞—è –¥–æ—Ä–æ–≥–∞ (–≤—ã–µ–∑–¥ –∑–∞ –≥–æ—Ä–æ–¥)
            south: j < horizontalRoadYs.length - 1 || (x === maxVerticalPos), // –¥–æ—Ä–æ–≥–∞ –Ω–∞ —é–≥: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä—è–¥ –ò–õ–ò –ø—Ä–∞–≤–∞—è –¥–æ—Ä–æ–≥–∞ (–≤—ã–µ–∑–¥ –∑–∞ –≥–æ—Ä–æ–¥)
            west: i > 0, // –µ—Å—Ç—å –¥–æ—Ä–æ–≥–∞ –Ω–∞ –∑–∞–ø–∞–¥, –µ—Å–ª–∏ –Ω–µ –∫—Ä–∞–π–Ω–∏–π –ª–µ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü
            east: i < verticalRoadXs.length - 1 // –µ—Å—Ç—å –¥–æ—Ä–æ–≥–∞ –Ω–∞ –≤–æ—Å—Ç–æ–∫, –µ—Å–ª–∏ –Ω–µ –∫—Ä–∞–π–Ω–∏–π –ø—Ä–∞–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü
          };

          const tl = initTrafficLightsForIntersection({
            PIXI,
            app,
            layer,
            x,
            y,
            roadWidth: CONFIG.ROAD_WIDTH,
            lampRadius: 9,
            cycle: { green: 750, yellow: 200 },
            roadConnections
          });
          const key = `${x},${y}`;
          intersectionKeyToTL.set(key, tl);

          // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Å–≤–µ—Ç–æ—Ñ–æ—Ä –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä–µ –∑–µ–ª–µ–Ω–æ–π –≤–æ–ª–Ω—ã
          trafficCoordinator.addTrafficLight(key, tl, x, y);
        }
      }

      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ—á–∫—É –Ω–∞—á–∞–ª–∞ –∑–µ–ª–µ–Ω–æ–π –≤–æ–ª–Ω—ã –≤ –ª–µ–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É
      if (verticalRoadXs.length > 0 && horizontalRoadYs.length > 0) {
        trafficCoordinator.setWaveOrigin(verticalRoadXs[0], horizontalRoadYs[0]);
      }
    }

    function drawDashedPath (g, points, dash, gap) {
      for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i], p2 = points[i + 1];
        const dx = p2.x - p1.x, dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        let t = 0;
        while (t <= len) {
          const from = t;
          const to = Math.min(t + dash, len);
          const sx = p1.x + dx * (from / len);
          const sy = p1.y + dy * (from / len);
          const ex = p1.x + dx * (to / len);
          const ey = p1.y + dy * (to / len);
          g.moveTo(sx, sy);
          g.lineTo(ex, ey);
          t += dash + gap;
        }
      }
    }

    function drawTrafficLights (layer) {
      CONFIG.TRAFFIC_LIGHTS.forEach(pos => {
        const c = new PIXI.Container();
        c.position.set(pos.x, pos.y);
        const pole = new PIXI.Graphics();
        pole.beginFill(0x555555).drawRect(-3, -20, 6, 40).endFill();
        const box = new PIXI.Graphics();
        box.beginFill(0x111111).drawRect(-8, -32, 16, 28).endFill();
        const red = new PIXI.Graphics(); red.beginFill(0xff0000).drawCircle(0, -26, 5).endFill();
        const yellow = new PIXI.Graphics(); yellow.beginFill(0xffff00).drawCircle(0, -16, 5).endFill();
        const green = new PIXI.Graphics(); green.beginFill(0x00ff00).drawCircle(0, -6, 5).endFill();
        c.addChild(pole, box, red, yellow, green);
        layer.addChild(c);
      });
    }

    function drawAlina (layer) {
      const house = CONFIG.ZONES.house;
      const container = new PIXI.Container();
      container.position.set(house.x + house.w - 40, house.y + house.h - 40);
      const circle = new PIXI.Graphics();
      circle.beginFill(0xffffff).drawCircle(0, 0, 15).endFill();
      const text = new PIXI.Text('A', {
        fontFamily: 'sans-serif',
        fontSize: 20,
        fill: 0x000000,
        stroke: 0xffffff,
        strokeThickness: 2
      });
      text.anchor.set(0.5);
      container.addChild(circle, text);
      layer.addChild(container);
    }

    function placeLabels (layer) {
      for (const key in CONFIG.ZONES) {
        const z = CONFIG.ZONES[key];
        let x, y;
        if (z.type === 'rect') {
          x = z.x + z.w / 2;
          y = z.y + z.h / 2;
        } else {
          x = z.x;
          y = z.y;
        }
        const text = new PIXI.Text(z.label, {
          fontFamily: 'sans-serif',
          fontSize: CONFIG.BASE_FONT,
          fill: 0xffffff,
          stroke: 0x000000,
          strokeThickness: 4
        });
        text.anchor.set(0.5);
        text.position.set(x, y);
        layer.addChild(text);
      }
    }

    function layout () {
      const w = 1200;
      const h = 800;
      const scale = Math.min(w / CONFIG.WORLD_WIDTH, h / CONFIG.WORLD_HEIGHT);
      world.scale.set(scale);
      world.pivot.set(0, 0);
      world.position.set(
        (w - CONFIG.WORLD_WIDTH * scale) / 2,
        (h - CONFIG.WORLD_HEIGHT * scale) / 2
      );
      labelsLayer.children.forEach(label => {
        label.scale.set(1 / scale);
      });
    }

    // ======= –ù–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è –ø–æ –≥—Ä–∞—Ñ—É –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–æ–≤ –∏ –∑–¥–∞–Ω–∏–π =======
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏ –∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–æ–≤
    function indexOfClosest (arr, value) {
      let bestIdx = 0;
      let bestDist = Infinity;
      for (let i = 0; i < arr.length; i++) {
        const d = Math.abs(arr[i] - value);
        if (d < bestDist) { bestDist = d; bestIdx = i; }
      }
      return bestIdx;
    }

    function getIntersectionCoord (i, j) {
      return { x: verticalRoadXs[i], y: horizontalRoadYs[j] };
    }

    function getNearestIntersectionIJ (x, y) {
      return { i: indexOfClosest(verticalRoadXs, x), j: indexOfClosest(horizontalRoadYs, y) };
    }

    // –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Ç–æ—á–∫—É –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —É –∑–¥–∞–Ω–∏—è: –Ω–∞ –±–ª–∏–∂–∞–π—à–µ–π –¥–æ—Ä–æ–≥–µ, —Ä—è–¥–æ–º —Å —Ü–µ–Ω—Ç—Ä–æ–º –∑–æ–Ω—ã
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç { stop: {x,y}, nearestIJ: {i,j}, orientation: 'vertical'|'horizontal' }
    function computeBuildingStop (buildingPos) {
      const nearestVXIndex = indexOfClosest(verticalRoadXs, buildingPos.x);
      const nearestVx = verticalRoadXs[nearestVXIndex];
      const distToV = Math.abs(buildingPos.x - nearestVx);

      const nearestHYIndex = indexOfClosest(horizontalRoadYs, buildingPos.y);
      const nearestHy = horizontalRoadYs[nearestHYIndex];
      const distToH = Math.abs(buildingPos.y - nearestHy);

      // –í—ã–±–∏—Ä–∞–µ–º –±–æ–ª–µ–µ –±–ª–∏–∑–∫—É—é –¥–æ—Ä–æ–≥—É
      if (distToV <= distToH) {
        // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π –¥–æ—Ä–æ–≥–µ: X —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω, Y ‚Äî –ø—Ä–æ–µ–∫—Ü–∏—è —Ü–µ–Ω—Ç—Ä–∞ –∑–¥–∞–Ω–∏—è
        const stopY = Math.max(horizontalRoadYs[0], Math.min(horizontalRoadYs[horizontalRoadYs.length - 1], buildingPos.y));
        const j = indexOfClosest(horizontalRoadYs, stopY);
        return { stop: { x: nearestVx, y: stopY }, nearestIJ: { i: nearestVXIndex, j }, orientation: 'vertical' };
      } else {
        // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π –¥–æ—Ä–æ–≥–µ: Y —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω, X ‚Äî –ø—Ä–æ–µ–∫—Ü–∏—è —Ü–µ–Ω—Ç—Ä–∞ –∑–¥–∞–Ω–∏—è
        const stopX = Math.max(verticalRoadXs[0], Math.min(verticalRoadXs[verticalRoadXs.length - 1], buildingPos.x));
        const i = indexOfClosest(verticalRoadXs, stopX);
        return { stop: { x: stopX, y: nearestHy }, nearestIJ: { i, j: nearestHYIndex }, orientation: 'horizontal' };
      }
    }

    // –ü–æ–∏—Å–∫ –ø—É—Ç–∏ –ø–æ —Å–µ—Ç–∫–µ –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–æ–≤ (BFS) –æ—Ç (i0,j0) –∫ (i1,j1). –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–æ–≤
    function buildIntersectionPath (fromIJ, toIJ) {
      const cols = verticalRoadXs.length;
      const rows = horizontalRoadYs.length;
      const key = (i, j) => `${i},${j}`;
      const queue = [];
      const visited = new Set();
      const parent = new Map();
      queue.push(fromIJ);
      visited.add(key(fromIJ.i, fromIJ.j));
      const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
      while (queue.length) {
        const cur = queue.shift();
        if (cur.i === toIJ.i && cur.j === toIJ.j) break;
        for (const [dx, dy] of dirs) {
          const ni = cur.i + dx;
          const nj = cur.j + dy;
          if (ni < 0 || nj < 0 || ni >= cols || nj >= rows) continue;
          const k = key(ni, nj);
          if (visited.has(k)) continue;
          visited.add(k);
          parent.set(k, key(cur.i, cur.j));
          queue.push({ i: ni, j: nj });
        }
      }
      // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É—Ç–∏
      const pathIJ = [];
      let ck = key(toIJ.i, toIJ.j);
      if (!visited.has(ck)) {
        // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π ‚Äî –µ—Å–ª–∏ –ø—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –æ—Å—Ç–∞—ë–º—Å—è –Ω–∞ –º–µ—Å—Ç–µ
        return [getIntersectionCoord(fromIJ.i, fromIJ.j)];
      }
      while (ck) {
        const [si, sj] = ck.split(',').map(Number);
        pathIJ.push({ i: si, j: sj });
        ck = parent.get(ck) || null;
      }
      pathIJ.reverse();
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫ ({x,y})
      return pathIJ.map(({ i, j }) => getIntersectionCoord(i, j));
    }

    // –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—É—Ç—å —Ç–æ–ª—å–∫–æ –ò–ó –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–∞ –í –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–æ–∫, –∑–∞—Ç–µ–º –∫ –∑–¥–∞–Ω–∏—é (–Ω–∞ –æ–±–æ—á–∏–Ω—É)
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫: [intersections..., buildingStop]
    function buildGraphPathToBuilding (startIJ, buildingPos) {
      const { stop, nearestIJ } = computeBuildingStop(buildingPos);
      const nodes = buildIntersectionPath(startIJ, nearestIJ); // —Ç–æ–ª—å–∫–æ –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–∏
      // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —É –∑–¥–∞–Ω–∏—è
      nodes.push(stop);
      return nodes;
    }

    function getDestinationCenter (locationKey) {
      const z = zoneGeometry.get(locationKey);
      if (z && z.center) return z.center;
      // fallback: –∏–∑ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞
      const def = CONFIG.ZONES[locationKey];
      if (!def) return { x: verticalRoadXs[0], y: horizontalRoadYs[0] };
      if (def.type === 'rect') return { x: def.x + def.w / 2, y: def.y + def.h / 2 };
      if (def.type === 'circle') return { x: def.x, y: def.y };
      return { x: verticalRoadXs[0], y: horizontalRoadYs[0] };
    }

    // –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç —Å —É—á—ë—Ç–æ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π: —Ç–æ–ª—å–∫–æ I->I –∏ I->B/B->I
    function buildCarPath () {
      const currentDestination = ROUTE_SCHEDULE[currentRouteIndex];
      if (!currentDestination) return [];

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–æ–∫
      let startIJ;
      if (car && car.position && (car.position.x !== 0 || car.position.y !== 0)) {
        startIJ = getNearestIntersectionIJ(car.position.x, car.position.y);
      } else {
        const housePos = getDestinationCenter('house');
        startIJ = getNearestIntersectionIJ(housePos.x, housePos.y);
      }

      const destCenter = getDestinationCenter(currentDestination.location);
      const graphPath = buildGraphPathToBuilding(startIJ, destCenter);

      // –ï—Å–ª–∏ –º–∞—à–∏–Ω–∞ –Ω–µ —Å—Ç–æ–∏—Ç —Ä–æ–≤–Ω–æ –Ω–∞ –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–µ —Å—Ç–∞—Ä—Ç–∞, –¥–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—ã–π –∫–æ—Ä–æ—Ç–∫–∏–π —Å–µ–≥–º–µ–Ω—Ç –¥–æ –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–∞
      const startIntersection = getIntersectionCoord(startIJ.i, startIJ.j);
      const needsPrefix = car && (Math.abs(car.position.x - startIntersection.x) > 1 || Math.abs(car.position.y - startIntersection.y) > 1);
      const path = needsPrefix ? [{ x: car.position.x, y: car.position.y }, startIntersection, ...graphPath] : graphPath;

      console.log(`üó∫Ô∏è Graph path to ${currentDestination.name}:`, path.map(p => `(${p.x.toFixed(0)},${p.y.toFixed(0)})`).join(' -> '));
      console.log(`üöó Car will start from segment 0: (${path[0]?.x?.toFixed(0) || 'N/A'},${path[0]?.y?.toFixed(0) || 'N/A'}) to (${path[1]?.x?.toFixed(0) || 'N/A'},${path[1]?.y?.toFixed(0) || 'N/A'})`);
      return path;
    }

    function createCar () {
      car = new PIXI.Container();

      // –ö—É–∑–æ–≤ –º–∞—à–∏–Ω—ã
      const body = new PIXI.Graphics();
      body.beginFill(0xff8800).drawRect(-60, -30, 120, 60).endFill();
      car.addChild(body);

      // –†–∞–¥–∏–∞—Ç–æ—Ä (–ø–µ—Ä–µ–¥–Ω—è—è —Ä–µ—à–µ—Ç–∫–∞) - –í–ü–ï–†–ï–î–ò
      const radiator = new PIXI.Graphics();
      radiator.beginFill(0x333333).drawRect(45, -25, 10, 50).endFill();
      // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª–æ—Å–∫–∏ —Ä–∞–¥–∏–∞—Ç–æ—Ä–∞
      for (let i = 0; i < 5; i++) {
        const line = new PIXI.Graphics();
        line.lineStyle(2, 0x666666);
        line.moveTo(45, -20 + i * 10);
        line.lineTo(55, -20 + i * 10);
        radiator.addChild(line);
      }
      car.addChild(radiator);

      // –ü–µ—Ä–µ–¥–Ω–∏–µ —Ñ–∞—Ä—ã - –í–ü–ï–†–ï–î–ò
      const leftHeadlight = new PIXI.Graphics();
      leftHeadlight.beginFill(0xffffaa).drawCircle(50, -20, 8).endFill();
      leftHeadlight.lineStyle(1, 0x333333);
      leftHeadlight.drawCircle(50, -20, 8);
      car.addChild(leftHeadlight);

      const rightHeadlight = new PIXI.Graphics();
      rightHeadlight.beginFill(0xffffaa).drawCircle(50, 20, 8).endFill();
      rightHeadlight.lineStyle(1, 0x333333);
      rightHeadlight.drawCircle(50, 20, 8);
      car.addChild(rightHeadlight);

      // –ó–∞–¥–Ω–∏–µ —Ñ–∞—Ä—ã - –°–ó–ê–î–ò
      const leftTailLight = new PIXI.Graphics();
      leftTailLight.beginFill(0xff0000).drawCircle(-50, -20, 6).endFill();
      leftTailLight.lineStyle(1, 0x333333);
      leftTailLight.drawCircle(-50, -20, 6);
      car.addChild(leftTailLight);

      const rightTailLight = new PIXI.Graphics();
      rightTailLight.beginFill(0xff0000).drawCircle(-50, 20, 6).endFill();
      rightTailLight.lineStyle(1, 0x333333);
      rightTailLight.drawCircle(-50, 20, 6);
      car.addChild(rightTailLight);

      // –ö—Ä—ã—à–∞ –º–∞—à–∏–Ω–∫–∏ (–∫–≤–∞–¥—Ä–∞—Ç–∏–∫ –ø–æ —Ä–∞–∑–º–µ—Ä—É –∞–≤–∞—Ç–∞—Ä–∫–∏)
      const roof = new PIXI.Graphics();
      roof.beginFill(0xcc6600).drawRect(-30, -30, 60, 60).endFill();
      roof.lineStyle(2, 0x333333);
      roof.drawRect(-30, -30, 60, 60);
      car.addChild(roof);

      // –ê–≤–∞—Ç–∞—Ä–∫–∞ –®–∏–Ω—ã (–∏—Å—Ö–æ–¥–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±–µ–∑ —Å–∫—Ä—É–≥–ª–µ–Ω–∏—è)
      avatar = PIXI.Sprite.from('shina.jpeg');
      avatar.anchor.set(0.5);
      avatar.width = 60;
      avatar.height = 60;
      car.addChild(avatar);

      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∏–≤–æ—Ç –º–∞—à–∏–Ω—ã –Ω–∞ –ø–µ—Ä–µ–¥–Ω—é—é —á–∞—Å—Ç—å (—Å–¥–≤–∏–≥–∞–µ–º –Ω–∞–∑–∞–¥ –Ω–∞ –ø–æ–ª–æ–≤–∏–Ω—É –¥–ª–∏–Ω—ã)
      // –¢–µ–ø–µ—Ä—å car.position –±—É–¥–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ –ø–µ—Ä–µ–¥–Ω—é—é —á–∞—Å—Ç—å –º–∞—à–∏–Ω—ã, –∞ –Ω–µ –Ω–∞ —Ü–µ–Ω—Ç—Ä
      car.pivot.set(0, 0); // –ø–∏–≤–æ—Ç –≤ –ª–µ–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É
      car.position.set(0, 0); // –Ω–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Å–≤–µ—Ç–æ—Ñ–æ—Ä–æ–≤
      carTrafficController = new CarTrafficController();

      // –ù–∞—á–∏–Ω–∞–µ–º —Å –ø–µ—Ä–≤–æ–≥–æ –ø—É–Ω–∫—Ç–∞ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è (—Ä–∞–±–æ—Ç–∞)
      currentRouteIndex = 1; // —Ä–∞–±–æ—Ç–∞, –∞ –Ω–µ –¥–æ–º
      isAtDestination = false;
      stayTimer = 0;

      // –°—Ç—Ä–æ–∏–º –ø—É—Ç—å —Å–Ω–∞—á–∞–ª–∞, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç–∞—Ä—Ç–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
      carPath = buildCarPath();
      carSegment = 0;
      carProgress = 0;

      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞—à–∏–Ω—É –Ω–∞ –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É –ø—É—Ç–∏ (–∫–æ—Ç–æ—Ä–∞—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–∞ –¥–æ—Ä–æ–≥–µ)
      if (carPath.length > 0) {
        // –°–¥–≤–∏–≥–∞–µ–º –º–∞—à–∏–Ω—É –Ω–∞–∑–∞–¥ –Ω–∞ –ø–æ–ª–æ–≤–∏–Ω—É –¥–ª–∏–Ω—ã, —á—Ç–æ–±—ã –ø–µ—Ä–µ–¥–Ω—è—è —á–∞—Å—Ç—å –±—ã–ª–∞ –≤ carPath[0]
        const carLength = 120; // –¥–ª–∏–Ω–∞ –º–∞—à–∏–Ω—ã
        const offsetX = -carLength / 2 * Math.cos(0); // –Ω–∞—á–∞–ª—å–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç 0
        const offsetY = -carLength / 2 * Math.sin(0);
        car.position.set(carPath[0].x + offsetX, carPath[0].y + offsetY);
        console.log('Car starts at:', carPath[0]);
      } else {
        // Fallback: —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞ –±–ª–∏–∂–∞–π—à—É—é –¥–æ—Ä–æ–≥—É –∫ –¥–æ–º—É
        const housePos = ROUTE_SCHEDULE[0].position;
        const roadPos = findNearestRoadPoint(housePos.x, housePos.y);
        const carLength = 120;
        const offsetX = -carLength / 2 * Math.cos(0);
        const offsetY = -carLength / 2 * Math.sin(0);
        car.position.set(roadPos.x + offsetX, roadPos.y + offsetY);
        console.log('Car fallback position:', roadPos);
      }

      decorLayer.addChild(car);
      app.ticker.add(updateCar);
      app.ticker.add(updateGameTime);

      updateRouteDisplay();
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
    function updateGameTime () {
      const now = Date.now();
      const deltaMs = now - lastTimeUpdate;
      lastTimeUpdate = now;

      // –£—Å–∫–æ—Ä—è–µ–º –≤—Ä–µ–º—è: 1 —Ä–µ–∞–ª—å–Ω–∞—è —Å–µ–∫—É–Ω–¥–∞ = timeSpeed –∏–≥—Ä–æ–≤—ã—Ö –º–∏–Ω—É—Ç
      const gameMinutes = (deltaMs / 1000) * timeSpeed;

      gameTime.minutes += gameMinutes;
      let hourGuard = 0; // –∑–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
      while (gameTime.minutes >= 60 && hourGuard < 100) {
        hourGuard++;
        gameTime.minutes -= 60;
        gameTime.hours += 1;
        if (gameTime.hours >= 24) {
          gameTime.hours = 0;
        }
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∏—Å–ø–ª–µ–π —á–∞—Å–æ–≤
      const hours = Math.floor(gameTime.hours).toString().padStart(2, '0');
      const minutes = Math.floor(gameTime.minutes).toString().padStart(2, '0');
      clockDisplay.text = `${hours}:${minutes}`;

      // –ï—Å–ª–∏ –Ω–∞—Ö–æ–¥–∏–º—Å—è –≤ –ø—É–Ω–∫—Ç–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è, —É–º–µ–Ω—å—à–∞–µ–º —Ç–∞–π–º–µ—Ä –æ–∂–∏–¥–∞–Ω–∏—è
      if (isAtDestination) {
        stayTimer -= gameMinutes / 60; // –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ –∏–≥—Ä–æ–≤—ã–µ —á–∞—Å—ã
        if (stayTimer <= 0) {
          // –í—Ä–µ–º—è –ø—Ä–µ–±—ã–≤–∞–Ω–∏—è –∑–∞–∫–æ–Ω—á–∏–ª–æ—Å—å, –µ–¥–µ–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø—É–Ω–∫—Ç—É
          nextDestination();
        }
      }
    }

    // –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø—É–Ω–∫—Ç—É –º–∞—Ä—à—Ä—É—Ç–∞
    function nextDestination () {
      // –°–∫—Ä—ã–≤–∞–µ–º –∞–≤–∞—Ç–∞—Ä–∫—É –≤ —Ç–µ–∫—É—â–µ–º –∑–¥–∞–Ω–∏–∏
      hideBuildingAvatar();

      currentRouteIndex = (currentRouteIndex + 1) % ROUTE_SCHEDULE.length;
      isAtDestination = false;
      stayTimer = 0;

      // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É—Ç—å –∫ –Ω–æ–≤–æ–º—É –ø—É–Ω–∫—Ç—É –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è
      carPath = buildCarPath();
      carSegment = 0;
      carProgress = 0;

      updateRouteDisplay();
    }

    // –§–∏–∫—Å–∏—Ä—É–µ–º –ø—Ä–∏–±—ã—Ç–∏–µ: –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏ –ø—É—Ç–∏ (–æ–±–æ—á–∏–Ω—ã)
    function checkArrival () {
      const currentDest = ROUTE_SCHEDULE[currentRouteIndex];
      if (!isAtDestination) {
        console.log(`Arrived at ${currentDest.name} (roadside).`);
        isAtDestination = true;
        stayTimer = currentDest.stayHours;
        updateRouteDisplay();

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞–ª–µ–Ω—å–∫—É—é –∞–≤–∞—Ç–∞—Ä–∫—É –≤ –∑–¥–∞–Ω–∏–∏
        showBuildingAvatar(currentDest.location);
      }
    }

    // –ü–æ–∫–∞–∑–∞—Ç—å –º–∞–ª–µ–Ω—å–∫—É—é –∞–≤–∞—Ç–∞—Ä–∫—É –≤ –∑–¥–∞–Ω–∏–∏
    function showBuildingAvatar (locationKey) {
      const buildingCenter = getDestinationCenter(locationKey);
      if (!buildingCenter) return;

      // –°–∫—Ä—ã–≤–∞–µ–º –∞–≤–∞—Ç–∞—Ä–∫—É –∏–∑ –º–∞—à–∏–Ω–∫–∏
      if (avatar) {
        avatar.visible = false;
      }

      // –°–æ–∑–¥–∞–µ–º –∞–≤–∞—Ç–∞—Ä–∫—É –≤ –∑–¥–∞–Ω–∏–∏ (—Ç–∞–∫–æ–≥–æ –∂–µ —Ä–∞–∑–º–µ—Ä–∞ –∫–∞–∫ –≤ –º–∞—à–∏–Ω–∫–µ)
      const avatarContainer = new PIXI.Container();

      // –ö–≤–∞–¥—Ä–∞—Ç–Ω—ã–π —Ñ–æ–Ω (–∏—Å—Ö–æ–¥–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±–µ–∑ —Å–∫—Ä—É–≥–ª–µ–Ω–∏—è)
      const background = new PIXI.Graphics();
      background.beginFill(0xffffff, 0.9);
      background.lineStyle(2, 0x333333);
      background.drawRect(-30, -30, 60, 60);
      background.endFill();
      avatarContainer.addChild(background);

      // –ê–≤–∞—Ç–∞—Ä–∫–∞ –®–∏–Ω—ã (–∏—Å—Ö–æ–¥–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±–µ–∑ —Å–∫—Ä—É–≥–ª–µ–Ω–∏—è)
      const buildingAvatar = PIXI.Sprite.from('shina.jpeg');
      buildingAvatar.anchor.set(0.5);
      buildingAvatar.width = 60;
      buildingAvatar.height = 60;
      avatarContainer.addChild(buildingAvatar);

      // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –≤ –ø—Ä–∞–≤–æ–º –Ω–∏–∂–Ω–µ–º —É–≥–ª—É –∑–¥–∞–Ω–∏—è
      const zone = zoneGeometry.get(locationKey);
      if (zone && zone.bounds) {
        if (zone.type === 'circle') {
          // –î–ª—è –∫—Ä—É–≥–ª—ã—Ö –∑–æ–Ω (–∏–Ω—Å—Ç–∏—Ç—É—Ç) - –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º —Å–ø—Ä–∞–≤–∞ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
          avatarContainer.position.set(
            zone.bounds.x + zone.bounds.r - 30,
            zone.bounds.y + zone.bounds.r - 30
          );
        } else {
          // –î–ª—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã—Ö –∑–æ–Ω
          avatarContainer.position.set(
            zone.bounds.x + zone.bounds.w - 30,
            zone.bounds.y + zone.bounds.h - 30
          );
        }
      } else {
        // Fallback: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—Ç—Ä –∑–¥–∞–Ω–∏—è
        avatarContainer.position.set(
          buildingCenter.x + 150,
          buildingCenter.y + 150
        );
      }

      decorLayer.addChild(avatarContainer);
      buildingAvatars.set(locationKey, avatarContainer);

      console.log(`üè† –ü–æ–∫–∞–∑–∞–Ω–∞ –∞–≤–∞—Ç–∞—Ä–∫–∞ –≤ –∑–¥–∞–Ω–∏–∏ ${locationKey}`, {
        zone: zone,
        buildingCenter: buildingCenter,
        position: avatarContainer.position
      });
    }

    // –°–∫—Ä—ã—Ç—å –∞–≤–∞—Ç–∞—Ä–∫—É –≤ –∑–¥–∞–Ω–∏–∏
    function hideBuildingAvatar () {
      const currentDest = ROUTE_SCHEDULE[currentRouteIndex];
      const avatarContainer = buildingAvatars.get(currentDest.location);
      if (avatarContainer && avatarContainer.parent) {
        avatarContainer.parent.removeChild(avatarContainer);
        buildingAvatars.delete(currentDest.location);
        console.log(`üè† –°–∫—Ä—ã—Ç–∞ –∞–≤–∞—Ç–∞—Ä–∫–∞ –≤ –∑–¥–∞–Ω–∏–∏ ${currentDest.location}`);
      }

      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–≤–∞—Ç–∞—Ä–∫—É –æ–±—Ä–∞—Ç–Ω–æ –≤ –º–∞—à–∏–Ω–∫–µ
      if (avatar) {
        avatar.visible = true;
      }
    }

    function updateCar (delta) {
      // –ï—Å–ª–∏ –Ω–∞—Ö–æ–¥–∏–º—Å—è –≤ –ø—É–Ω–∫—Ç–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è, –Ω–µ –¥–≤–∏–≥–∞–µ–º—Å—è
      if (isAtDestination) {
        checkArrival(); // –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
        return;
      }

      const speed = CAR_SPEED * delta;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –Ω–∞—Å –ø—É—Ç—å
      if (carPath.length < 2) {
        // console.log('No valid path, rebuilding...');
        carPath = buildCarPath();
        carSegment = 0;
        carProgress = 0;
        return;
      }

      // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ carSegment –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –ø—Ä–µ–¥–µ–ª–∞—Ö
      if (carSegment >= carPath.length - 1) {
        // –î–æ—Å—Ç–∏–≥–ª–∏ –∫–æ–Ω—Ü–∞ –ø—É—Ç–∏
        // console.log('Reached end of path');
        const finalX = carPath[carPath.length - 1].x;
        const finalY = carPath[carPath.length - 1].y;
        const carLength = 120;
        const offsetX = -carLength / 2 * Math.cos(car.rotation);
        const offsetY = -carLength / 2 * Math.sin(car.rotation);
        car.position.set(finalX + offsetX, finalY + offsetY);
        checkArrival();
        return;
      }

      let p1 = carPath[carSegment];
      let p2 = carPath[carSegment + 1];
      let dx = p2.x - p1.x;
      let dy = p2.y - p1.y;
      let segLen = Math.hypot(dx, dy);

      // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —Å–µ–≥–º–µ–Ω—Ç –∏–º–µ–µ—Ç –Ω—É–ª–µ–≤—É—é –¥–ª–∏–Ω—É, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É
      if (segLen < 0.1) {
        // console.log('Zero-length segment, skipping to next');
        carSegment++;
        carProgress = 0;
        return;
      }

      // üö¶ –ü–†–û–í–ï–†–ö–ê –°–í–ï–¢–û–§–û–†–ê –ü–ï–†–ï–î –ü–†–ò–ë–õ–ò–ñ–ï–ù–ò–ï–ú –ö –ü–ï–†–ï–ö–†–ï–°–¢–ö–£ üö¶
      if (carTrafficController) {
        // –í—ã—á–∏—Å–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –ø–µ—Ä–µ–¥–Ω–µ–π —á–∞—Å—Ç–∏ –º–∞—à–∏–Ω—ã
        const carLength = 120;
        const offsetX = carLength / 2 * Math.cos(car.rotation);
        const offsetY = carLength / 2 * Math.sin(car.rotation);
        const currentPos = {
          x: car.position.x + offsetX,
          y: car.position.y + offsetY
        };
        const targetIntersection = { x: p2.x, y: p2.y }; // —Ü–µ–ª–µ–≤–æ–π –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫
        const roadPositions = { verticalRoadXs, horizontalRoadYs };

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–ª–µ–≤–æ–≥–æ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–∞
        const distanceToIntersection = Math.hypot(currentPos.x - targetIntersection.x, currentPos.y - targetIntersection.y);

        // –û–¢–õ–ê–î–ö–ê: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥–≤–∏–∂–µ–Ω–∏–∏ (—Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ —Å–µ–∫—É–Ω–¥—ã)
        if (carSegment === 0 && carProgress < 20) {
          console.log(`üöó DEBUG: segment=${carSegment}, progress=${carProgress.toFixed(1)}, distance=${distanceToIntersection.toFixed(1)}, carPos=(${car.position.x.toFixed(0)},${car.position.y.toFixed(0)}), frontPos=(${currentPos.x.toFixed(0)},${currentPos.y.toFixed(0)}) to=(${targetIntersection.x},${targetIntersection.y})`);
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤–µ—Ç–æ—Ñ–æ—Ä —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏:
        // 1. –ù–∞—Ö–æ–¥–∏–º—Å—è –≤ –∑–æ–Ω–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ (30-60 –ø–∏–∫—Å–µ–ª–µ–π –¥–æ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–∞)
        // 2. –ò –ù–ï —Å—Ç–æ–∏–º –ø—Ä—è–º–æ –Ω–∞ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–µ —Å—Ç–∞—Ä—Ç–∞ 
        if (distanceToIntersection <= 60 && distanceToIntersection > 15) { // –∑–æ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–≤–µ—Ç–æ—Ñ–æ—Ä–∞
          const trafficCheck = carTrafficController.checkTrafficLights(
            currentPos,
            targetIntersection,
            intersectionKeyToTL,
            roadPositions
          );

          if (!trafficCheck.canMove) {
            // –ö—Ä–∞—Å–Ω—ã–π —Å–≤–µ—Ç - –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è
            console.log(`üö¶ –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–µ—Ä–µ–¥ –∫—Ä–∞—Å–Ω—ã–º —Å–≤–µ—Ç–æ–º –Ω–∞ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–µ (${targetIntersection.x}, ${targetIntersection.y}), distance=${distanceToIntersection.toFixed(1)}`);
            return; // –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º carProgress - –º–∞—à–∏–Ω–∞ —Å—Ç–æ–∏—Ç
          }
        }
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ —Ç–µ–∫—É—â–µ–º—É —Å–µ–≥–º–µ–Ω—Ç—É
      carProgress += speed;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–≤–µ—Ä—à–∏–ª–∏ –ª–∏ –º—ã —Ç–µ–∫—É—â–∏–π —Å–µ–≥–º–µ–Ω—Ç
      if (carProgress >= segLen) {

        // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Å–µ–≥–º–µ–Ω—Ç—É
        carProgress = carProgress - segLen; // –æ—Å—Ç–∞—Ç–æ–∫ –ø–µ—Ä–µ–Ω–æ—Å–∏–º
        carSegment++;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏ –º—ã –∫–æ–Ω—Ü–∞ –ø—É—Ç–∏
        if (carSegment >= carPath.length - 1) {
          // console.log('Reached final destination');
          const finalX = carPath[carPath.length - 1].x;
          const finalY = carPath[carPath.length - 1].y;
          const carLength = 120;
          const offsetX = -carLength / 2 * Math.cos(car.rotation);
          const offsetY = -carLength / 2 * Math.sin(car.rotation);
          car.position.set(finalX + offsetX, finalY + offsetY);
          checkArrival();
          return;
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–æ–≤–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
        p1 = carPath[carSegment];
        p2 = carPath[carSegment + 1];
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        segLen = Math.hypot(dx, dy);
      }

      // –í—ã—á–∏—Å–ª—è–µ–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é –Ω–∞ —Å–µ–≥–º–µ–Ω—Ç–µ
      const t = segLen > 0 ? Math.min(1, carProgress / segLen) : 0;
      const newX = p1.x + dx * t;
      const newY = p1.y + dy * t;

      // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –º–∞—à–∏–Ω–∫–∏ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
      if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
        car.rotation = Math.atan2(dy, dx);
        avatar.rotation = -car.rotation;
      }

      // –°–¥–≤–∏–≥–∞–µ–º –º–∞—à–∏–Ω—É –Ω–∞–∑–∞–¥ –Ω–∞ –ø–æ–ª–æ–≤–∏–Ω—É –¥–ª–∏–Ω—ã, —á—Ç–æ–±—ã –ø–µ—Ä–µ–¥–Ω—è—è —á–∞—Å—Ç—å –±—ã–ª–∞ –≤ (newX, newY)
      const carLength = 120; // –¥–ª–∏–Ω–∞ –º–∞—à–∏–Ω—ã
      const offsetX = -carLength / 2 * Math.cos(car.rotation);
      const offsetY = -carLength / 2 * Math.sin(car.rotation);
      car.position.set(newX + offsetX, newY + offsetY);

      // console.log(`Car at segment ${carSegment}/${carPath.length - 1}, progress: ${carProgress.toFixed(1)}/${segLen.toFixed(1)}, pos: (${newX.toFixed(1)}, ${newY.toFixed(1)})`);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏–±—ã—Ç–∏–µ –≤ –ø—É–Ω–∫—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è: –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏ –ø—É—Ç–∏
      const lastPoint = carPath[carPath.length - 1];
      const distToLast = Math.hypot(car.position.x - lastPoint.x, car.position.y - lastPoint.y);
      if (distToLast < 20) {
        checkArrival();
      }
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
    const panningController = new PanningController();

    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º body –¥–ª—è –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è
    document.body.style.width = '1200px';
    document.body.style.height = '800px';
    document.body.style.overflow = 'auto';
  </script>
</body>

</html>
