<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <title>Карта Шины</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    canvas {
      display: block;
      width: 1200px;
      height: 800px;
      border: 2px solid #444;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
</head>

<body>
  <script type="module">
    import { initTrafficLightsForIntersection, getDirectionForSegment, Direction } from './trafficLights.js';
    const CONFIG = {
      WORLD_WIDTH: 3000,
      WORLD_HEIGHT: 2000,
      GRID_STEP: 100,
      ROAD_SPACING_H: 450,  // шаг между вертикальными дорогами (7 дорог)
      ROAD_SPACING_V: 567,  // шаг между горизонтальными дорогами (4 дороги)
      ROAD_MARGIN: 150,
      ROAD_WIDTH: 48,
      ROAD_LINE_WIDTH: 12,
      DASH_LENGTH: 60,
      DASH_GAP: 60,
      COLORS: {
        grid: 0xffffff,
        border: 0xff0000,
        road: 0x666666,
        roadLine: 0xffffff,
        house: 0xffe0e0,
        work: 0xe0e8ff,
        box: 0xfff2cc,
        relatives: 0xe0ffe0,
        institute: 0xd0f0ff,
        lotFill: 0xf1e9d2,
        lotBorder: 0x777777,
      },
      LOTS: {
        SLOTS_PER_BLOCK: 6,
        GAP: 10,
        PADDING: 20,
        MAX_MULTI_SLOT: 3,
        MIN_LOT_HEIGHT: 60,
        FILL_ALPHA: 0.9
      },
      ZONE_LAYOUT: {
        // индексы блоков: 0..(кол-во-1) слева-направо и сверху-вниз
        house: { block: { i: 0, j: 0 }, cells: [[0, 0]] },           // 1x1
        relatives: { block: { i: 5, j: 0 }, cells: [[1, 0]] },       // 1x1
        work: { block: { i: 3, j: 1 }, cells: [[0, 1], [1, 1]] },    // 2x1 (две колонки в одном ряду)
        box: { block: { i: 1, j: 2 }, cells: [[0, 1], [0, 2]] },     // 1x2 (две строки в одном столбце)
        institute: { block: { i: 5, j: 2 }, cells: [[0, 0], [1, 0], [1, 1]] } // Г-образно 3 ячейки
      },
      ZONES: {
        house: { type: 'rect', x: 200, y: 200, w: 440, h: 750, label: 'Дом Шины' },
        relatives: { type: 'rect', x: 1300, y: 200, w: 440, h: 750, label: 'Родственники' },
        work: { type: 'rect', x: 1840, y: 1100, w: 440, h: 700, label: 'Работа' },
        box: { type: 'rect', x: 200, y: 1100, w: 440, h: 700, label: 'Бокс' },
        institute: { type: 'circle', x: 2550, y: 1425, r: 200, label: 'Институт', alpha: 0.6 },
      },
      TRAFFIC_LIGHTS: [
        { x: 600, y: 1283 },
        { x: 1050, y: 1283 },
        { x: 1500, y: 1283 },
        { x: 1950, y: 1283 }
      ],
      CAR_PATH: [
        { x: 600, y: 1283 },
        { x: 1050, y: 1283 },
        { x: 1500, y: 1283 },
        { x: 1950, y: 1283 }
      ],
      BASE_FONT: 32
    };

    const CAR_SPEED = 2;

    // globals
    let app, world, gridLayer, roadsLayer, lotsLayer, zonesLayer, labelsLayer, intersectionsLayer, decorLayer, borderLayer, uiLayer, car;
    let carPath = [], carSegment = 0, carProgress = 0;
    let avatar;
    let horizontalRoadYs = [], verticalRoadXs = [];
    let hoverLabel;
    // Хранилище светофоров по ключу перекрёстка
    const intersectionKeyToTL = new Map();

    setupApp();
    setupWorld();
    createCar();
    layout();
    window.addEventListener('resize', () => {
      app.renderer.resize(1200, 800);
      app.stage.hitArea = new PIXI.Rectangle(0, 0, 1200, 800);
      layout();
    });

    function setupApp () {
      app = new PIXI.Application({
        width: 1200,
        height: 800,
        autoDensity: true,
        resolution: window.devicePixelRatio || 1,
        backgroundColor: 0x3a6f3e
      });
      document.body.appendChild(app.view);
      // Включаем систему событий для всей сцены
      app.stage.eventMode = 'static';
      app.stage.hitArea = new PIXI.Rectangle(0, 0, 1200, 800);
    }

    function setupWorld () {
      world = new PIXI.Container();
      app.stage.addChild(world);

      gridLayer = new PIXI.Container();
      roadsLayer = new PIXI.Container();
      lotsLayer = new PIXI.Container();
      zonesLayer = new PIXI.Container();
      labelsLayer = new PIXI.Container();
      intersectionsLayer = new PIXI.Container();
      decorLayer = new PIXI.Container();
      borderLayer = new PIXI.Container();

      world.addChild(gridLayer, roadsLayer, intersectionsLayer, lotsLayer, zonesLayer, labelsLayer, decorLayer, borderLayer);

      drawGrid(gridLayer);
      drawRoads(roadsLayer);
      createIntersections(intersectionsLayer);
      drawLots(lotsLayer);
      drawZones(zonesLayer);
      // placeLabels(labelsLayer);
      // Светофоры теперь создаются на каждом перекрёстке
      createTrafficLightsForAllIntersections(decorLayer);
      // drawAlina(decorLayer);
      drawWorldBorder(borderLayer);

      uiLayer = new PIXI.Container();
      app.stage.addChild(uiLayer);
      const title = new PIXI.Text('Карта города (наблюдатель)', {
        fontFamily: 'sans-serif',
        fontSize: 20,
        fill: 0xffffff,
        stroke: 0x000000,
        strokeThickness: 3
      });
      title.position.set(10, 10);
      uiLayer.addChild(title);
    }

    function getRoadPositions () {
      const margin = CONFIG.ROAD_MARGIN;
      const horizontalPositions = [];
      const verticalPositions = [];
      const availableHeight = CONFIG.WORLD_HEIGHT - 2 * margin;
      for (let i = 0; i < 4; i++) {
        const y = margin + (availableHeight / (4 - 1)) * i;
        horizontalPositions.push(y);
      }
      const availableWidth = CONFIG.WORLD_WIDTH - 2 * margin;
      for (let i = 0; i < 7; i++) {
        const x = margin + (availableWidth / (7 - 1)) * i;
        verticalPositions.push(x);
      }
      const maxVerticalPos = verticalPositions[verticalPositions.length - 1];
      return { horizontalPositions, verticalPositions, maxVerticalPos };
    }

    function drawGrid (layer) {
      const g = new PIXI.Graphics();
      g.lineStyle(1, CONFIG.COLORS.grid, 0.15);
      for (let i = 0; i <= CONFIG.WORLD_WIDTH; i += CONFIG.GRID_STEP) {
        g.moveTo(i, 0); g.lineTo(i, CONFIG.WORLD_HEIGHT);
      }
      for (let i = 0; i <= CONFIG.WORLD_HEIGHT; i += CONFIG.GRID_STEP) {
        g.moveTo(0, i); g.lineTo(CONFIG.WORLD_WIDTH, i);
      }
      layer.addChild(g);
    }

    function drawWorldBorder (layer) {
      const g = new PIXI.Graphics();
      g.lineStyle(8, CONFIG.COLORS.border, 1.0, 0);
      g.drawRect(0, 0, CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT);
      layer.addChild(g);
    }

    function randInt (min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateBuildingSlots (maxSlots) {
      const sizes = [];
      const target = randInt(Math.max(3, Math.floor(maxSlots / 2)), maxSlots);
      let used = 0;
      while (used < target) {
        const remaining = target - used;
        const maxTake = Math.min(remaining, CONFIG.LOTS.MAX_MULTI_SLOT);
        const roll = Math.random();
        let take = 1;
        if (maxTake >= 3 && roll < 0.18) take = 3;
        else if (maxTake >= 2 && roll < 0.55) take = 2;
        sizes.push(take);
        used += take;
      }
      return sizes;
    }

    function drawLots (layer) {
      if (!horizontalRoadYs.length || !verticalRoadXs.length) return;
      const roadHalf = CONFIG.ROAD_WIDTH / 2;
      const cols = 2; // по горизонтали
      const rows = 3; // по вертикали
      const gap = CONFIG.LOTS.GAP;
      const padding = CONFIG.LOTS.PADDING;

      for (let j = 0; j < horizontalRoadYs.length - 1; j++) {
        const yTop = horizontalRoadYs[j] + roadHalf;
        const yBottom = horizontalRoadYs[j + 1] - roadHalf;
        const blockHeight = Math.max(0, yBottom - yTop);
        const innerHeight = Math.max(0, blockHeight - padding * 2);
        if (innerHeight <= 0) continue;
        const totalGapsV = gap * (rows - 1);
        const lotHeight = (innerHeight - totalGapsV) / rows;

        for (let i = 0; i < verticalRoadXs.length - 1; i++) {
          const xLeft = verticalRoadXs[i] + roadHalf;
          const xRight = verticalRoadXs[i + 1] - roadHalf;
          const blockWidth = Math.max(0, xRight - xLeft);
          const innerWidth = Math.max(0, blockWidth - padding * 2);
          if (innerWidth <= 0) continue;
          const totalGapsH = gap * (cols - 1);
          const lotWidth = (innerWidth - totalGapsH) / cols;

          const startX = xLeft + padding;
          const startY = yTop + padding;

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const rx = startX + c * (lotWidth + gap);
              const ry = startY + r * (lotHeight + gap);
              const g = new PIXI.Graphics();
              g.lineStyle(1, CONFIG.COLORS.lotBorder, 0.9);
              g.beginFill(CONFIG.COLORS.lotFill, CONFIG.LOTS.FILL_ALPHA);
              g.drawRect(rx, ry, lotWidth, lotHeight);
              g.endFill();
              layer.addChild(g);
            }
          }
        }
      }
    }

    function drawZones (layer) {
      if (!horizontalRoadYs.length || !verticalRoadXs.length) return;
      const roadHalf = CONFIG.ROAD_WIDTH / 2;
      const cols = 2;
      const rows = 3;
      const gap = CONFIG.LOTS.GAP;
      const padding = CONFIG.LOTS.PADDING;

      const zoneLayout = CONFIG.ZONE_LAYOUT;
      const blocksAcross = verticalRoadXs.length - 1;
      const blocksDown = horizontalRoadYs.length - 1;

      function getBlockRect (bi, bj) {
        const yTop = horizontalRoadYs[bj] + roadHalf;
        const yBottom = horizontalRoadYs[bj + 1] - roadHalf;
        const xLeft = verticalRoadXs[bi] + roadHalf;
        const xRight = verticalRoadXs[bi + 1] - roadHalf;
        const blockWidth = Math.max(0, xRight - xLeft);
        const blockHeight = Math.max(0, yBottom - yTop);
        const innerWidth = Math.max(0, blockWidth - padding * 2);
        const innerHeight = Math.max(0, blockHeight - padding * 2);
        const totalGapsH = gap * (cols - 1);
        const totalGapsV = gap * (rows - 1);
        const lotWidth = (innerWidth - totalGapsH) / cols;
        const lotHeight = (innerHeight - totalGapsV) / rows;
        const startX = xLeft + padding;
        const startY = yTop + padding;
        return { startX, startY, lotWidth, lotHeight };
      }

      function drawZoneRect (x, y, w, h, color) {
        const g = new PIXI.Graphics();
        g.lineStyle(2, 0x333333, 0.9);
        g.beginFill(color, 1.0);
        g.drawRect(x, y, w, h);
        g.endFill();
        layer.addChild(g);
        return g;
      }

      function drawLabel (textValue, x, y, maxWidth) {
        const label = createWrappedLabel(textValue, CONFIG.BASE_FONT, Math.max(60, maxWidth * 0.9));
        label.position.set(x, y);
        layer.addChild(label);
      }

      function createWrappedLabel (textValue, fontSize, maxWidth) {
        const style = new PIXI.TextStyle({
          fontFamily: 'sans-serif',
          fontSize,
          fill: 0x000000,
          wordWrap: true,
          wordWrapWidth: maxWidth,
          breakWords: true,
          align: 'center',
          stroke: 0xffffff,
          strokeThickness: 4
        });
        const label = new PIXI.Text(textValue, style);
        label.anchor.set(0.5);
        return label;
      }

      function drawZoneFromCells (name, colorKey) {
        const conf = zoneLayout[name];
        if (!conf) return;
        const bi = conf.block.i;
        const bj = conf.block.j;
        if (bi < 0 || bj < 0 || bi >= blocksAcross || bj >= blocksDown) return;
        const { startX, startY, lotWidth, lotHeight } = getBlockRect(bi, bj);

        // Для института рисуем Г-образно, иначе — объединённый прямоугольник
        if (name === 'institute') {
          // Ячейки по конфигу в координатах сетки лотов
          const cells = conf.cells.map(([c, r]) => ({ c, r }));

          // Вспомогательная: группировать последовательные числа
          const groupConsecutive = (arr) => {
            const groups = [];
            let start = null, prev = null;
            arr.forEach(v => {
              if (start === null) { start = v; prev = v; return; }
              if (v === prev + 1) { prev = v; return; }
              groups.push([start, prev]);
              start = v; prev = v;
            });
            if (start !== null) groups.push([start, prev]);
            return groups;
          };

          // Горизонтальные полосы: по каждому ряду объединяем соседние колонки и ЗАПОЛНЯЕМ внутренние гэпы
          const rowsUsed = Array.from(new Set(cells.map(x => x.r))).sort((a, b) => a - b);
          rowsUsed.forEach(r => {
            const colsHere = cells.filter(x => x.r === r).map(x => x.c).sort((a, b) => a - b);
            const seqs = groupConsecutive(colsHere);
            seqs.forEach(([c0, c1]) => {
              const x = startX + c0 * (lotWidth + gap);
              const y = startY + r * (lotHeight + gap);
              const w = (c1 - c0 + 1) * lotWidth + (c1 - c0) * gap; // перекрываем горизонтальные гэпы
              const h = lotHeight;
              drawZoneRect(x, y, w, h, CONFIG.COLORS[colorKey]);
            });
          });

          // Вертикальные полосы: по каждой колонке объединяем соседние ряды и ЗАПОЛНЯЕМ вертикальные гэпы
          const colsUsed = Array.from(new Set(cells.map(x => x.c))).sort((a, b) => a - b);
          colsUsed.forEach(c => {
            const rowsHere = cells.filter(x => x.c === c).map(x => x.r).sort((a, b) => a - b);
            const seqs = groupConsecutive(rowsHere);
            seqs.forEach(([r0, r1]) => {
              const x = startX + c * (lotWidth + gap);
              const y = startY + r0 * (lotHeight + gap);
              const w = lotWidth;
              const h = (r1 - r0 + 1) * lotHeight + (r1 - r0) * gap; // перекрываем вертикальные гэпы
              drawZoneRect(x, y, w, h, CONFIG.COLORS[colorKey]);
            });
          });

          // Подпись в центре тяжести фигуры (среднее центров занятых ячеек)
          const centers = cells.map(({ c, r }) => ({
            cx: startX + c * (lotWidth + gap) + lotWidth / 2,
            cy: startY + r * (lotHeight + gap) + lotHeight / 2
          }));
          const cgx = centers.reduce((s, p) => s + p.cx, 0) / centers.length;
          const cgy = centers.reduce((s, p) => s + p.cy, 0) / centers.length;
          // Ширина для переноса: охватывающая ширина фигуры
          const minX = Math.min(...cells.map(({ c }) => startX + c * (lotWidth + gap)));
          const maxX = Math.max(...cells.map(({ c }) => startX + c * (lotWidth + gap) + lotWidth));
          drawLabel(CONFIG.ZONES[name].label, cgx, cgy, maxX - minX);
          return;
        }

        // Общее объединение для прямоугольных зон
        let minC = Infinity, minR = Infinity, maxC = -Infinity, maxR = -Infinity;
        conf.cells.forEach(([c, r]) => {
          minC = Math.min(minC, c);
          minR = Math.min(minR, r);
          maxC = Math.max(maxC, c);
          maxR = Math.max(maxR, r);
        });
        const x = startX + minC * (lotWidth + gap);
        const y = startY + minR * (lotHeight + gap);
        const w = (maxC - minC + 1) * lotWidth + (maxC - minC) * gap;
        const h = (maxR - minR + 1) * lotHeight + (maxR - minR) * gap;
        drawZoneRect(x, y, w, h, CONFIG.COLORS[colorKey]);
        drawLabel(CONFIG.ZONES[name].label, x + w / 2, y + h / 2, w);
      }

      drawZoneFromCells('house', 'house');
      drawZoneFromCells('relatives', 'relatives');
      drawZoneFromCells('work', 'work');
      drawZoneFromCells('box', 'box');
      drawZoneFromCells('institute', 'institute');
    }

    function drawRoads (layer) {
      const { horizontalPositions, verticalPositions, maxVerticalPos } = getRoadPositions();
      horizontalRoadYs = horizontalPositions;
      verticalRoadXs = verticalPositions;

      // Рисуем горизонтальные дороги
      horizontalRoadYs.forEach(y => {
        const h = [{ x: verticalRoadXs[0], y: y }, { x: maxVerticalPos, y: y }];
        const roadH = new PIXI.Graphics();
        roadH.lineStyle(CONFIG.ROAD_WIDTH, CONFIG.COLORS.road, 1);
        roadH.moveTo(h[0].x, h[0].y);
        roadH.lineTo(h[1].x, h[1].y);
        layer.addChild(roadH);
        const dashH = new PIXI.Graphics();
        dashH.lineStyle(CONFIG.ROAD_LINE_WIDTH, CONFIG.COLORS.roadLine, 1);
        drawDashedPath(dashH, h, CONFIG.DASH_LENGTH, CONFIG.DASH_GAP);
        layer.addChild(dashH);
      });

      // Рисуем вертикальные дороги
      verticalRoadXs.forEach(x => {
        let v;
        if (x === maxVerticalPos) {
          v = [{ x: x, y: 0 }, { x: x, y: CONFIG.WORLD_HEIGHT }];
        } else {
          v = [{ x: x, y: horizontalRoadYs[0] }, { x: x, y: horizontalRoadYs[horizontalRoadYs.length - 1] }];
        }
        const roadV = new PIXI.Graphics();
        roadV.lineStyle(CONFIG.ROAD_WIDTH, CONFIG.COLORS.road, 1);
        roadV.moveTo(v[0].x, v[0].y);
        roadV.lineTo(v[1].x, v[1].y);
        layer.addChild(roadV);
        const dashV = new PIXI.Graphics();
        dashV.lineStyle(CONFIG.ROAD_LINE_WIDTH, CONFIG.COLORS.roadLine, 1);
        drawDashedPath(dashV, v, CONFIG.DASH_LENGTH, CONFIG.DASH_GAP);
        layer.addChild(dashV);
      });
    }

    function createIntersections (layer) {
      // Подпись при наведении
      if (!hoverLabel) {
        hoverLabel = new PIXI.Text('', {
          fontFamily: 'sans-serif',
          fontSize: CONFIG.BASE_FONT,
          fill: 0xffff66,
          stroke: 0x000000,
          strokeThickness: 4
        });
        hoverLabel.anchor.set(0.5, 1);
        hoverLabel.visible = false;
        labelsLayer.addChild(hoverLabel);
      }

      const hitRadius = 60;
      for (let j = 0; j < horizontalRoadYs.length; j++) {
        for (let i = 0; i < verticalRoadXs.length; i++) {
          const x = verticalRoadXs[i];
          const y = horizontalRoadYs[j];
          const labelText = String.fromCharCode(65 + i) + (j + 1);
          const g = new PIXI.Graphics();
          // Прозрачный круг-хитбокс + явная hitArea для стабильного хит-теста
          g.beginFill(0x000000, 0).drawCircle(0, 0, hitRadius).endFill();
          g.position.set(x, y);
          g.eventMode = 'static';
          g.cursor = 'pointer';
          g.hitArea = new PIXI.Circle(0, 0, hitRadius);
          const show = () => {
            hoverLabel.text = labelText;
            hoverLabel.position.set(x, y - 16);
            hoverLabel.visible = true;
          };
          const hide = () => {
            hoverLabel.visible = false;
          };
          g.on('pointerover', show);
          g.on('pointerout', hide);
          g.on('pointerenter', show);
          g.on('pointerleave', hide);
          layer.addChild(g);
        }
      }
    }

    function createTrafficLightsForAllIntersections (layer) {
      intersectionKeyToTL.clear();
      const { maxVerticalPos } = getRoadPositions();

      for (let j = 0; j < horizontalRoadYs.length; j++) {
        for (let i = 0; i < verticalRoadXs.length; i++) {
          const x = verticalRoadXs[i];
          const y = horizontalRoadYs[j];

          // Определяем, какие дороги есть в каждом направлении
          const roadConnections = {
            north: j > 0 || (x === maxVerticalPos), // дорога на север: внутренний ряд ИЛИ правая дорога (выезд за город)
            south: j < horizontalRoadYs.length - 1 || (x === maxVerticalPos), // дорога на юг: внутренний ряд ИЛИ правая дорога (выезд за город)
            west: i > 0, // есть дорога на запад, если не крайний левый столбец
            east: i < verticalRoadXs.length - 1 // есть дорога на восток, если не крайний правый столбец
          };

          const tl = initTrafficLightsForIntersection({
            PIXI,
            app,
            layer,
            x,
            y,
            roadWidth: CONFIG.ROAD_WIDTH,
            lampRadius: 9,
            cycle: { green: 4500, yellow: 1200 },
            roadConnections
          });
          intersectionKeyToTL.set(`${x},${y}`, tl);
        }
      }
    }

    function drawDashedPath (g, points, dash, gap) {
      for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i], p2 = points[i + 1];
        const dx = p2.x - p1.x, dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        let t = 0;
        while (t <= len) {
          const from = t;
          const to = Math.min(t + dash, len);
          const sx = p1.x + dx * (from / len);
          const sy = p1.y + dy * (from / len);
          const ex = p1.x + dx * (to / len);
          const ey = p1.y + dy * (to / len);
          g.moveTo(sx, sy);
          g.lineTo(ex, ey);
          t += dash + gap;
        }
      }
    }

    function drawTrafficLights (layer) {
      CONFIG.TRAFFIC_LIGHTS.forEach(pos => {
        const c = new PIXI.Container();
        c.position.set(pos.x, pos.y);
        const pole = new PIXI.Graphics();
        pole.beginFill(0x555555).drawRect(-3, -20, 6, 40).endFill();
        const box = new PIXI.Graphics();
        box.beginFill(0x111111).drawRect(-8, -32, 16, 28).endFill();
        const red = new PIXI.Graphics(); red.beginFill(0xff0000).drawCircle(0, -26, 5).endFill();
        const yellow = new PIXI.Graphics(); yellow.beginFill(0xffff00).drawCircle(0, -16, 5).endFill();
        const green = new PIXI.Graphics(); green.beginFill(0x00ff00).drawCircle(0, -6, 5).endFill();
        c.addChild(pole, box, red, yellow, green);
        layer.addChild(c);
      });
    }

    function drawAlina (layer) {
      const house = CONFIG.ZONES.house;
      const container = new PIXI.Container();
      container.position.set(house.x + house.w - 40, house.y + house.h - 40);
      const circle = new PIXI.Graphics();
      circle.beginFill(0xffffff).drawCircle(0, 0, 15).endFill();
      const text = new PIXI.Text('A', {
        fontFamily: 'sans-serif',
        fontSize: 20,
        fill: 0x000000,
        stroke: 0xffffff,
        strokeThickness: 2
      });
      text.anchor.set(0.5);
      container.addChild(circle, text);
      layer.addChild(container);
    }

    function placeLabels (layer) {
      for (const key in CONFIG.ZONES) {
        const z = CONFIG.ZONES[key];
        let x, y;
        if (z.type === 'rect') {
          x = z.x + z.w / 2;
          y = z.y + z.h / 2;
        } else {
          x = z.x;
          y = z.y;
        }
        const text = new PIXI.Text(z.label, {
          fontFamily: 'sans-serif',
          fontSize: CONFIG.BASE_FONT,
          fill: 0xffffff,
          stroke: 0x000000,
          strokeThickness: 4
        });
        text.anchor.set(0.5);
        text.position.set(x, y);
        layer.addChild(text);
      }
    }

    function layout () {
      const w = 1200;
      const h = 800;
      const scale = Math.min(w / CONFIG.WORLD_WIDTH, h / CONFIG.WORLD_HEIGHT);
      world.scale.set(scale);
      world.pivot.set(0, 0);
      world.position.set(
        (w - CONFIG.WORLD_WIDTH * scale) / 2,
        (h - CONFIG.WORLD_HEIGHT * scale) / 2
      );
      labelsLayer.children.forEach(label => {
        label.scale.set(1 / scale);
      });
    }

    function buildCarPath () {
      return CONFIG.CAR_PATH;
    }

    function createCar () {
      carPath = buildCarPath();
      car = new PIXI.Container();

      const body = new PIXI.Graphics();
      body.beginFill(0xff8800).drawRect(-60, -30, 120, 60).endFill();
      car.addChild(body);

      avatar = PIXI.Sprite.from('shina.jpeg');
      avatar.anchor.set(0.5);
      avatar.width = 60;
      avatar.height = 60;
      car.addChild(avatar);
      car.position.set(carPath[0].x, carPath[0].y);
      decorLayer.addChild(car);
      app.ticker.add(updateCar);
    }

    function updateCar (delta) {
      const speed = CAR_SPEED * delta;
      let p1 = carPath[carSegment];
      let p2 = carPath[(carSegment + 1) % carPath.length];
      let dx = p2.x - p1.x;
      let dy = p2.y - p1.y;
      let segLen = Math.hypot(dx, dy);

      // Координаты потенциальной новой позиции
      let nextProgress = carProgress + speed;
      let tNext = nextProgress / segLen;
      let nx = p1.x + dx * tNext;
      let ny = p1.y + dy * tNext;

      // Проверяем, пересекаем ли центр перекрёстка и нужно ли ждать на красный
      const cx = p2.x; // точки пути совпадают с центрами перекрёстков
      const cy = p2.y;
      const approachingIntersection = (Math.sign(dx) !== 0 && Math.sign(dx) === Math.sign(cx - car.position.x)) || (Math.sign(dy) !== 0 && Math.sign(dy) === Math.sign(cy - car.position.y));

      if (approachingIntersection) {
        const key = `${cx},${cy}`;
        const tl = intersectionKeyToTL.get(key);
        if (tl) {
          const dir = getDirectionForSegment(dx, dy);
          if (!tl.isPassAllowed(dir)) {
            // Стоим перед центром перекрёстка на расстоянии стоп-линии
            const stopDist = CONFIG.ROAD_WIDTH * 0.6;
            const distToCenter = Math.hypot(cx - car.position.x, cy - car.position.y);
            if (distToCenter <= stopDist) {
              // Ждём: не двигаемся дальше и выравниваем на стоп-линии
              const angle = Math.atan2(dy, dx);
              const sx = cx - Math.cos(angle) * stopDist;
              const sy = cy - Math.sin(angle) * stopDist;
              car.position.set(sx, sy);
              car.rotation = angle;
              avatar.rotation = -car.rotation;
              return; // стоп, пока красный
            }
          }
        }
      }

      carProgress = nextProgress;
      while (carProgress > segLen) {
        carProgress -= segLen;
        carSegment = (carSegment + 1) % carPath.length;
        p1 = carPath[carSegment];
        p2 = carPath[(carSegment + 1) % carPath.length];
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        segLen = Math.hypot(dx, dy);
        tNext = carProgress / segLen;
      }
      const t = carProgress / segLen;
      car.position.set(p1.x + dx * t, p1.y + dy * t);
      car.rotation = Math.atan2(dy, dx);
      avatar.rotation = -car.rotation;
    }
  </script>
</body>

</html>
