# Упрощенная архитектура проекта "Карта Шины"

## Обзор рефакторинга

Текущий `main.js` (2179 строк) будет разбит на простые логические модули для улучшения читаемости и поддерживаемости кода.

## Упрощенная структура папок

```
src/
├── config/                        # Конфигурация
│   └── gameConfig.js              # Основная конфигурация игры
├── game/                          # Основная игровая логика
│   ├── Game.js                    # Главный класс игры
│   ├── TimeManager.js             # Управление временем
│   ├── PauseManager.js            # Управление паузой и скоростью
│   ├── DayNightManager.js         # Управление днем/ночью
│   └── StateManager.js            # Система состояний Шины
├── rendering/                     # Рендеринг
│   ├── WorldRenderer.js           # Отрисовка мира
│   ├── CarRenderer.js             # Отрисовка машины
│   └── UIRenderer.js              # Отрисовка UI
├── entities/                      # Игровые объекты
│   ├── Car.js                     # Машина
│   ├── TrafficLight.js            # Светофор
│   └── Shina.js                   # Персонаж Шина с состояниями
├── systems/                       # Системы (уже существуют)
│   ├── trafficLights.js           # СУЩЕСТВУЕТ - система светофоров
│   ├── carTrafficControl.js       # СУЩЕСТВУЕТ - контроль движения
│   └── panning.js                 # СУЩЕСТВУЕТ - панорамирование
├── utils/                         # Утилиты
│   ├── geometry.js                # Геометрические функции
│   ├── math.js                    # Математические утилиты
│   └── storage.js                 # Работа с localStorage
└── main.js                        # Точка входа (упрощенная)
```

## Детальное описание модулей

### config/

#### gameConfig.js
- Весь CONFIG объект из main.js
- Константы цветов, размеров, маршрутов
- Настройки зон и светофоров

### game/

#### Game.js
- Главный класс игры
- Инициализация PIXI приложения
- Основной игровой цикл
- Координация всех систем

#### TimeManager.js
- Управление игровым временем (gameTime)
- Форматирование дат и времени
- Обновление времени в реальном времени

#### PauseManager.js
- Управление паузой игры
- Управление скоростью симуляции
- Сохранение/загрузка настроек

#### DayNightManager.js
- Переключение режимов дня/ночи
- Управление освещением
- Цветовые фильтры

#### StateManager.js
- Управление состояниями Шины
- Модификаторы доступности
- Логика "поимки" персонажа

### rendering/

#### WorldRenderer.js
- Отрисовка сетки, дорог, зон, лотов
- Создание перекрестков
- Управление слоями PIXI

#### CarRenderer.js
- Отрисовка машины
- Анимация поворотов
- Обновление позиции

#### UIRenderer.js
- Отрисовка UI элементов
- Меню, уведомления, дисплеи
- Обработка событий UI

### entities/

#### Car.js
- Класс машины
- Физика движения
- Логика маршрутизации
- Интеграция со светофорами

#### TrafficLight.js
- Класс светофора
- Логика переключения
- Визуальное представление

#### Shina.js
- Класс персонажа Шина
- Состояния доступности
- Логика взаимодействия с друзьями

### systems/

#### trafficLights.js (СУЩЕСТВУЕТ)
- Система светофоров на перекрестках
- Координатор "зеленой волны"
- Управление фазами светофоров

#### carTrafficControl.js (СУЩЕСТВУЕТ)
- Контроль движения машины
- Проверка светофоров
- Расчет позиций остановки

#### panning.js (СУЩЕСТВУЕТ)
- Панорамирование карты
- Масштабирование
- Touch и mouse события

### utils/

#### geometry.js
- Геометрические функции
- Поиск ближайших точек
- Расчеты расстояний
- Построение путей

#### math.js
- Математические утилиты
- Интерполяция
- Случайные числа

#### storage.js
- Работа с localStorage
- Сохранение настроек
- Загрузка конфигурации

## Принципы упрощенной архитектуры

### 1. Минимализм
- Только необходимые модули
- Простая структура папок
- Минимум абстракций

### 2. Понятность
- Четкое разделение по функциональности
- Логичные названия модулей
- Простые зависимости

### 3. Практичность
- Легко начать рефакторинг
- Постепенная миграция
- Сохранение работоспособности

## Преимущества упрощенной архитектуры

### 1. Простота
- Легко понять структуру
- Быстро начать работу
- Минимум сложности

### 2. Гибкость
- Легко добавлять новые модули
- Простое изменение структуры
- Быстрая итерация

### 3. Поддерживаемость
- Код разбит на логические части
- Упрощена навигация
- Легче находить и исправлять баги

## Текущий прогресс рефакторинга

### ✅ Выполнено

НЕ ЗАБЫВАТЬ АПДЕЙТИТЬ ПЛАН МИГРАЦИИ ПОСЛЕ КАЖДОГО ШАГА РЕФАКТОРИНГА

#### Этап 0: Анализ существующих модулей ✅
1. ✅ Документировать функциональность `trafficLights.js`
2. ✅ Документировать функциональность `carTrafficControl.js`
3. ✅ Документировать функциональность `panning.js`
4. ✅ Определить зависимости между модулями

#### Этап 1: Создание структуры ✅
1. ✅ Создать папки: `config/`, `game/`, `rendering/`, `entities/`, `systems/`, `utils/`
2. ✅ Переместить существующие модули в `systems/`
3. ✅ Создать базовые файлы новых модулей

#### Этап 2: Извлечение конфигурации ✅
1. ✅ Перенести CONFIG в `config/gameConfig.js`
2. ✅ Обновить импорты в main.js

#### Этап 3: Выделение менеджеров (частично)
1. ✅ Создать `TimeManager.js` - перенести функции времени
2. ✅ Создать `PauseManager.js` - перенести функции паузы
3. ✅ Создать `DayNightManager.js` - перенести функции дня/ночи
4. ✅ **ЗАВЕРШЕНО**: Перенести функции управления паузой из main.js в PauseManager.js
   - Удалены дублирующиеся функции: `saveSpeedSettings()`, `loadSpeedSettings()`, `pauseGame()`, `resumeGame()`, `togglePause()`, `updatePauseButton()`, `updatePauseModeText()`, `showSpeedNotification()`
   - Удалены глобальные переменные: `SPEED_MULTIPLIER`, `isSpeedBoosted`, `isGamePaused`
   - Обновлен код для использования `pauseManager` вместо старых функций
   - main.js стал на ~60 строк короче
5. ✅ **ЗАВЕРШЕНО**: Перенести функции времени из main.js в TimeManager.js
   - Удалены дублирующиеся функции: `getMonthName()`, `getDayOfWeekShort()`, `getDayOfWeek()`, `getDaysInMonth()`, `formatGameDateTime()`
   - Удалены глобальные переменные: `gameTime`, `BASE_TIME_SPEED`, `lastTimeUpdate`
   - Обновлена функция `updateGameTime()` для использования `timeManager.update()`
   - Все функции теперь получают время через `timeManager.getGameTime()`
   - main.js стал еще на ~40 строк короче
6. ✅ **ЗАВЕРШЕНО**: Перенести функции дня/ночи из main.js в DayNightManager.js
   - Удалены дублирующиеся функции-обертки: `loadDayNightSettings()`, `isNightTime()`, `createCityNightOverlay()`, `updateNightMode()`, `toggleDayNightMode()`, `updateDayNightModeText()`
   - Перенесены функции цветовых фильтров: `applyNightColorFilter()`, `resetDayColorFilter()`, `addLightSource()`, `removeLightSource()`
   - Удалены глобальные переменные: `dayNightMode`, `isNightMode`, `cityNightOverlay`, `nightTransitionSpeed`, `currentCityNightAlpha`
   - Обновлен код для использования `dayNightManager` вместо старых функций
  - Исправлена ошибка `ReferenceError: updateNightMode is not defined`
  - main.js стал еще на ~50 строк короче

#### Этап 4: Выделение рендеринга ✅ (ЗАВЕРШЕН)
1. ✅ Создать `WorldRenderer.js` - перенести функции отрисовки мира (все части 4.1.1-4.1.5)
2. ✅ Создать `CarRenderer.js` - перенести функции отрисовки машины
   - Удалены дублирующиеся функции: `createCar()`, `updateCar()`
   - Удалены глобальные переменные: `carPath`, `carSegment`, `carProgress`, `isAtDestination`, `stayTimer`
   - Обновлен код для использования `carRenderer` вместо старых функций
  - Исправлена скорость машины (использование `config.BASE_CAR_SPEED` вместо `2.0`)
  - main.js стал еще на ~200 строк короче
3. ✅ Создать `UIRenderer.js` - перенести UI функции
   - Создан класс `UIRenderer` с полной функциональностью
   - Перенесены функции: `initMenu()`, `showMenuNotification()`, `updateRouteDisplay()`, `updateDateTimeDisplay()`, `updateZoomButton()`
   - Добавлена поддержка управления состоянием маршрута
   - Реализована интеграция с другими менеджорами
   - Удалены глобальные переменные: `datetimeDisplay`, `routeDisplay`
   - Обновлен код для использования `uiRenderer` вместо старых функций
   - main.js стал еще на ~100 строк короче

### 🔄 В процессе

#### Этап 5: Выделение сущностей ⏳ (готов к началу)

**4.1. Создание WorldRenderer.js (разбито на части)**

**Часть 4.1.1: Базовая структура и отрисовка сетки** ✅
- Создать класс `WorldRenderer` с базовой структурой
- Перенести функции:
  - `drawGrid(layer)` - отрисовка сетки (строки 594-604)
  - `drawWorldBorder(layer)` - отрисовка границ мира (строки 606-611)
- Создать базовые методы:
  - `constructor()` - инициализация
  - `init()` - настройка слоев
  - `render()` - основной метод отрисовки
- **Зависимости**: CONFIG, PIXI
- **Сложность**: Низкая (2 функции, ~20 строк)
- **⚠️ Проблема решена**: Изначально WorldRenderer создавал собственные слои в `app.stage`, что приводило к тому, что сетка не перемещалась при панорамировании. Исправлено: теперь WorldRenderer использует существующие слои из `world` контейнера, который управляется системой панорамирования.

**Часть 4.1.2: Отрисовка дорог** ✅
- Перенести функции:
  - `drawRoads(layer)` - отрисовка горизонтальных и вертикальных дорог (строки 856-893)
  - `drawDashedPath(g, points, dash, gap)` - отрисовка пунктирных линий (строки 1007-1025)
  - `getRoadPositions()` - расчет позиций дорог (строки 580-592)
- Добавить управление слоями дорог
- **Зависимости**: CONFIG, PIXI, `getRoadPositions()`
- **Сложность**: Средняя (3 функции, ~80 строк)
- **✅ Выполнено**: Все функции отрисовки дорог перенесены в WorldRenderer. Добавлены методы для получения позиций дорог. Обновлен main.js для использования WorldRenderer вместо глобальных переменных.

**Часть 4.1.3: Отрисовка зон и лотов** ✅
- Перенести функции:
  - `drawZones(layer)` - отрисовка зон (строки 679-708)
  - `drawZoneRect(x, y, w, h, color)` - отрисовка прямоугольных зон (строки 709-718)
  - `drawZoneFromCells(name, colorKey)` - отрисовка зон из ячеек (строки 742-855)
  - `drawLots(layer)` - отрисовка лотов (строки 634-678)
  - `generateBuildingSlots(maxSlots)` - генерация слотов зданий (строки 617-632)
- Добавить управление цветами и стилями зон
- **Зависимости**: CONFIG, PIXI, `randInt()`
- **Сложность**: Высокая (5 функций, ~200 строк)
- **✅ Выполнено**: Все функции отрисовки зон и лотов перенесены в WorldRenderer. Добавлена поддержка сложной геометрии зон (включая Г-образные зоны). Обновлен метод render() для включения отрисовки зон и лотов.

**Часть 4.1.4: Отрисовка перекрестков и светофоров** ✅
- Перенести функции:
  - `createIntersections(layer)` - создание перекрестков (строки 895-1020)
  - `drawTrafficLights(layer)` - отрисовка светофоров (строки 1027-1041)
- Добавить обработку событий hover для перекрестков
- **Зависимости**: CONFIG, PIXI, глобальные переменные `horizontalRoadYs`, `verticalRoadXs`, `hoverLabel`, `labelsLayer`
- **Сложность**: Высокая (2 функции, ~150 строк, сложная логика событий)
- **✅ Выполнено**: Все функции отрисовки перекрестков и светофоров перенесены в WorldRenderer. Добавлена поддержка интерактивных элементов с hover-эффектами для мобильных и десктопных устройств. Удалены глобальные функции и переменные из main.js. main.js стал еще на ~70 строк короче.

**Часть 4.1.5: Отрисовка персонажей и меток** ✅
- Перенести функции:
  - `drawAlina(layer)` - отрисовка персонажа Алины (строки 1043-1059)
  - `placeLabels(layer)` - размещение меток зон (строки 1061-1080+)
- Добавить управление метками и подписями
- **Зависимости**: CONFIG, PIXI
- **Сложность**: Средняя (2 функции, ~50 строк)
- **✅ Выполнено**: Все функции отрисовки персонажей и меток перенесены в WorldRenderer. Добавлена поддержка отрисовки персонажа Алины и размещения меток зон. Удалены глобальные функции из main.js. main.js стал еще на ~40 строк короче.

**4.2. Создание CarRenderer.js** ✅
- ✅ **ЗАВЕРШЕНО**: Перенести функции отрисовки машины
  - Создан класс `CarRenderer` с полной функциональностью
  - Перенесена функция `createCar()` с визуальным созданием машины
  - Перенесена функция `updateCar()` с логикой движения и анимации
  - Добавлены методы управления состоянием машины
- ✅ **ЗАВЕРШЕНО**: Анимация поворотов
  - Реализована анимация поворотов машины в направлении движения
  - Добавлена синхронизация поворота аватарки
- ✅ **ЗАВЕРШЕНО**: Обновление позиции
  - Реализовано движение по пути с проверкой светофоров
  - Добавлена синхронизация с глобальными переменными
  - main.js стал на ~200 строк короче

**4.3. Создание UIRenderer.js** ✅
- ✅ **ЗАВЕРШЕНО**: Перенести UI функции
  - Создан класс `UIRenderer` с полной функциональностью
  - Перенесены функции: `initMenu()`, `showMenuNotification()`, `updateRouteDisplay()`, `updateDateTimeDisplay()`, `updateZoomButton()`
  - Добавлена поддержка управления состоянием маршрута
  - Реализована интеграция с другими менеджорами
- ✅ **ЗАВЕРШЕНО**: Меню, уведомления, дисплеи
  - Полная поддержка бургер-меню с обработкой событий
  - Система уведомлений с анимацией
  - Дисплеи маршрута и времени с автообновлением
- ✅ **ЗАВЕРШЕНО**: Обработка событий UI
  - Обработка кнопок масштабирования
  - Синхронизация с panningController
  - Интеграция с системой маршрутов
  - main.js стал еще на ~100 строк короче

## Рекомендации по выполнению WorldRenderer

### Порядок выполнения частей:
1. **Часть 4.1.1** - Начать с простой структуры и базовых функций
2. **Часть 4.1.2** - Добавить дороги (зависит от `getRoadPositions()`)
3. **Часть 4.1.3** - Добавить зоны и лоты (самая сложная часть)
4. **Часть 4.1.4** - Добавить перекрестки и светофоры (сложная логика событий)
5. **Часть 4.1.5** - Завершить персонажами и метками

### Потенциальные проблемы:
- **Глобальные переменные**: `horizontalRoadYs`, `verticalRoadXs`, `hoverLabel`, `labelsLayer` нужно будет передавать в конструктор
- **Зависимости между функциями**: `drawRoads()` зависит от `getRoadPositions()`, `drawLots()` зависит от `horizontalRoadYs` и `verticalRoadXs`
- **События**: `createIntersections()` содержит сложную логику обработки событий для мобильных и десктопных устройств
- **Слои PIXI**: Нужно правильно управлять слоями и их порядком
- **⚠️ РЕШЕНО - Панорамирование**: WorldRenderer должен использовать существующие слои из `world` контейнера, а не создавать собственные в `app.stage`, иначе элементы не будут перемещаться при панорамировании

### Стратегия тестирования:
- После каждой части проверять, что отрисовка работает корректно
- Тестировать на мобильных и десктопных устройствах
- Проверять производительность (особенно для зон и лотов)

## Пример структуры WorldRenderer по частям

### Часть 4.1.1: Базовая структура
```javascript
class WorldRenderer {
  constructor(config, pixiApp) {
    this.config = config;
    this.app = pixiApp;
    this.layers = {};
  }

  init() {
    // Создание слоев
    this.layers.grid = new PIXI.Container();
    this.layers.border = new PIXI.Container();
    // ...
  }

  drawGrid(layer) {
    // Перенесенная функция drawGrid
  }

  drawWorldBorder(layer) {
    // Перенесенная функция drawWorldBorder
  }

  render() {
    this.drawGrid(this.layers.grid);
    this.drawWorldBorder(this.layers.border);
  }
}
```

### Часть 4.1.2: Добавление дорог
```javascript
// Добавить в класс WorldRenderer:
drawRoads(layer) {
  // Перенесенная функция drawRoads
}

drawDashedPath(g, points, dash, gap) {
  // Перенесенная функция drawDashedPath
}

getRoadPositions() {
  // Перенесенная функция getRoadPositions
}
```

### Часть 4.1.3: Добавление зон и лотов
```javascript
// Добавить в класс WorldRenderer:
drawZones(layer) { /* ... */ }
drawZoneRect(x, y, w, h, color) { /* ... */ }
drawZoneFromCells(name, colorKey) { /* ... */ }
drawLots(layer) { /* ... */ }
generateBuildingSlots(maxSlots) { /* ... */ }
```

### Часть 4.1.4: Добавление перекрестков и светофоров
```javascript
// Добавить в класс WorldRenderer:
createIntersections(layer) { /* ... */ }
drawTrafficLights(layer) { /* ... */ }
```

### Часть 4.1.5: Добавление персонажей и меток
```javascript
// Добавить в класс WorldRenderer:
drawAlina(layer) { /* ... */ }
placeLabels(layer) { /* ... */ }
```

### ⏳ Планируется

#### Этап 5: Выделение сущностей
1. Создать `Car.js` - класс машины
2. Создать `TrafficLight.js` - класс светофора
3. Создать `Shina.js` - класс персонажа с состояниями

#### Этап 6: Утилиты
1. Создать `geometry.js` - геометрические функции
2. Создать `math.js` - математические утилиты
3. Создать `storage.js` - работа с localStorage

#### Этап 7: Рефакторинг main.js
1. Упростить main.js до минимума
2. Использовать импорты модулей
3. Тестирование работоспособности

#### Этап 8: Игровая механика (будущее развитие)
1. Реализовать систему состояний Шины
2. Добавить систему друзей и сообщений
3. Создать UI для игроков-друзей

## План миграции

### Этап 0: Анализ существующих модулей
1. Документировать функциональность `trafficLights.js`
2. Документировать функциональность `carTrafficControl.js`
3. Документировать функциональность `panning.js`
4. Определить зависимости между модулями

### Этап 1: Создание структуры
1. Создать папки: `config/`, `game/`, `rendering/`, `entities/`, `systems/`, `utils/`
2. Переместить существующие модули в `systems/`
3. Создать базовые файлы новых модулей

### Этап 2: Извлечение конфигурации
1. Перенести CONFIG в `config/gameConfig.js`
2. Обновить импорты в main.js

### Этап 3: Выделение менеджеров
1. Создать `TimeManager.js` - перенести функции времени
2. Создать `PauseManager.js` - перенести функции паузы
3. Создать `DayNightManager.js` - перенести функции дня/ночи

### Этап 4: Выделение рендеринга
1. Создать `WorldRenderer.js` - перенести функции отрисовки мира
2. Создать `CarRenderer.js` - перенести функции отрисовки машины
3. Создать `UIRenderer.js` - перенести UI функции

### Этап 5: Выделение сущностей
1. Создать `Car.js` - класс машины
2. Создать `TrafficLight.js` - класс светофора
3. Создать `Shina.js` - класс персонажа с состояниями

### Этап 6: Утилиты
1. Создать `geometry.js` - геометрические функции
2. Создать `math.js` - математические утилиты
3. Создать `storage.js` - работа с localStorage

### Этап 7: Рефакторинг main.js
1. Упростить main.js до минимума
2. Использовать импорты модулей
3. Тестирование работоспособности

### Этап 8: Игровая механика (будущее развитие)
1. Реализовать систему состояний Шины
2. Добавить систему друзей и сообщений
3. Создать UI для игроков-друзей

## Игровая механика (будущее развитие)

### Система состояний Шины
- `available` - доступен для "поимки"
- `atWork` - на работе, недоступен
- `sleeping` - спит, недоступен
- `driving` - едет, недоступен

### Система друзей
- Отправка сообщений (звонки, СМС)
- Проверка доступности Шины
- Система уведомлений

## Производительность

### Текущие показатели
- 60 FPS стабильно
- Память: ~50MB
- Время загрузки: <2 сек

## Заключение

Упрощенная архитектура обеспечивает:
- **Простоту** - легко понять и начать работу
- **Гибкость** - легко изменять и расширять
- **Практичность** - можно начать рефакторинг прямо сейчас
- **Постепенность** - миграция по частям без поломки функциональности

Эта структура идеально подходит для начала рефакторинга и может быть расширена в будущем при необходимости.
