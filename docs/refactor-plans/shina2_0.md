### **ОГЛАВЛЕНИЕ ПЛАНА РАЗРАБОТКИ: "ШИНА 2.0"**

**ЭТАП 0: ПОДГОТОВКА И РАСШИРЕНИЕ МИРА (Foundation & World Expansion)**
*   0.1. Расширение `gameConfig.js`: Централизация всех новых параметров для балансировки.
*   0.2. Расширение Игрового Мира: Добавление новых локаций (Редбери, магазины, стройки, парки).

**ЭТАП 1: ЯДРО ЛОГИКИ - КОНЕЧНЫЙ АВТОМАТ И СИСТЕМА ПРИОРИТЕТОВ (Core Logic - State Machine & Priority System)**
*   1.1. Рефакторинг `Shina.js`: Внедрение паттерна "Конечный автомат" (State Machine) с разделением обработчиков `onMessage` и `onPhoneCall`.
*   1.2. Реализация Системы Приоритетов: Внедрение механик "Соскучился" и "Усталость".

**ЭТАП 2: ИГРОВОЙ ЦИКЛ - ДИНАМИЧЕСКАЯ СИСТЕМА ЗАДАЧ И РАСПИСАНИЯ (Gameplay Loop - Dynamic Task & Schedule System)**
*   2.1. Улучшение сущности `Task`: Добавление `endTime` и других необходимых полей.
*   2.2. Создание **динамического** `ScheduleManager`: Разработка "живого" менеджера расписания с возможностью добавления задач "на лету".
*   2.3. Интеграция в игровой цикл: "Оживление" Шины в соответствии с его динамическим расписанием.

**ЭТАП 3: СИСТЕМА ВЗАИМОДЕЙСТВИЯ - "ДРУЗЬЯ" (Interaction Layer - The "Friends" System)**
*   3.1. Создание `CommunicationManager`: Эмуляция входящих звонков и СМС.
*   3.2. Введение сущности `Invitation`: Создание класса для хранения приглашений от друзей.
*   3.3. Интеграция с `Shina.js`: Обработка входящих сообщений в зависимости от состояния.

**ЭТАП 4: КУЛЬМИНАЦИЯ - ПРИНЯТИЕ РЕШЕНИЙ И УСЛОВИЕ ПОБЕДЫ (Climax - Decision Making & Win Condition)**
*   4.1. Реализация `DecisionEngine`: Разработка логики анализа приглашений и задач.
*   4.2. Механика отмены задач: Реализация логики отмены текущих дел ради встречи.
*   4.3. Проверка условия победы: Триггер на успешное принятие приглашения.

**ЭТАП 5: ФИНАЛИЗАЦИЯ И ПОЛЬЗОВАТЕЛЬСКИЙ ОПЫТ (Finalization & UX)**
*   5.1. Реализация экрана победы "УРАААА" по прибытии в "Редбери".
*   5.2. Интеграция с `JournalManager`: Добавление записей о принятии приглашения и встрече.
*   5.3. Подготовка к симуляции баланса: Обеспечение легкого доступа ко всем параметрам из `CONFIG.BALANCING`.

***

### **ПОДРОБНОЕ ОПИСАНИЕ ПЛАНА (ПЕРВАЯ ПОЛОВИНА: ЭТАПЫ 0-2)**

#### **ЭТАП 0: ПОДГОТОВКА И РАСШИРЕНИЕ МИРА**

**Цель:** Создать прочный фундамент для нового функционала. Это включает централизацию всех настраиваемых параметров и значительное расширение игрового мира, чтобы сделать его более живым и разнообразным.

**Детали реализации:**

**0.1. Расширение `gameConfig.js`**

Модифицируем `src/config/gameConfig.js`, чтобы все игровые константы были в одном месте. Это критически важно для будущей балансировки и симуляций.

```javascript
// Внутри файла src/config/gameConfig.js

export const CONFIG = {
  // ... существующие настройки ...

  BALANCING: {
    // ... параметры из предыдущего ответа ...
    SIMULATION_MESSAGES_PER_3_HOURS: 3, // Кол-во сообщений от "друзей" за 3 игровых часа
  },

  // Приоритеты для задач (чем выше, тем важнее)
  TASK_PRIORITIES: {
    SLEEP: 100,
    WORK: 90,
    CONSTRUCTION_VISIT: 80,
    RELATIVES_VISIT: 70,
    BARBER: 50,
    SHOPPING: 40,
    PARK_WALK: 30,
    DOMESTIC_TASK: 20, // Домашние дела
    FRIENDS_MEETING: 0 // Начальный приоритет динамический, см. friendshipPriority
  },

  // ... существующие настройки ...
};
```

**0.2. Расширение Игрового Мира**

Добавим новые локации, чтобы обогатить расписание Шины. Процесс состоит из трех шагов: добавить цвета, определить расположение в `ZONE_LAYOUT` и задать метки в `ZONES`.

1.  **Добавить цвета в `CONFIG.COLORS`**:

    ```javascript
    COLORS: {
      // ...
      redberry: 0xffa07a,      // Светло-лососевый
      shop: 0xadd8e6,          // Светло-голубой
      market: 0x90ee90,         // Светло-зеленый
      barber: 0xf0e68c,         // Хаки
      construction: 0xd2b48c,  // Загар
      park: 0x3cb371,          // Морская зелень
    },
    ```

2.  **Добавить расположения в `CONFIG.ZONE_LAYOUT`**: Я разместил объекты так, чтобы заполнить карту, избегая существующих зон.

    ```javascript
    ZONE_LAYOUT: {
      // ... существующие зоны
      redberry: { block: { i: 3, j: 2 }, cells: [[1, 2]] },         // D3, справа-снизу
      shop: { block: { i: 0, j: 1 }, cells: [[0, 1], [1, 1]] },     // A2, 2x1 (горизонтально)
      market: { block: { i: 0, j: 0 }, cells: [[0,0],[1,0],[0,1],[1,1],[0,2],[1,2]] }, // A1, 6x2 (занимает весь блок)
      barber: { block: { i: 6, j: 1 }, cells: [[0, 0]] },           // G2
      construction1: { block: { i: 4, j: 0 }, cells: [[0, 0]] },    // E1
      construction2: { block: { i: 2, j: 2 }, cells: [[1, 0]] },    // C3
      // Парки
      park_large1: { block: { i: 1, j: 0 }, cells: [[0,1],[1,1],[0,2],[1,2]] }, // B1, 2x3 (занимает 4 ячейки)
      park_large2: { block: { i: 4, j: 2 }, cells: [[0,1],[1,1],[0,2],[1,2]] }, // E3, 2x3 (занимает 4 ячейки)
      park_medium1: { block: { i: 0, j: 2 }, cells: [[0,0],[1,0]] },// A3, 2x2
      // и так далее для остальных парков...
    },
    ```

3.  **Добавить метки в `CONFIG.ZONES`**:

    ```javascript
    ZONES: {
      // ...
      redberry: { label: 'Редбери' },
      shop: { label: 'Магазин' },
      market: { label: 'Рынок' },
      barber: { label: 'Барбершоп' },
      construction1: { label: 'Стройка 1' },
      construction2: { label: 'Стройка 2' },
      park_large1: { label: 'Парк' },
      // ...
    }
    ```

---

#### **ЭТАП 1: ЯДРО ЛОГИКИ - КОНЕЧНЫЙ АВТОМАТ И СИСТЕМА ПРИОРИТЕТОВ**

**Цель:** Заменить примитивную систему состояний на полноценный, расширяемый Конечный автомат (State Machine). Ввести механику приоритетов, которая станет основой для принятия решений.

**Детали реализации:**

**1.1. Рефакторинг `Shina.js`: Внедрение Конечного Автомата**

Это ключевой архитектурный рефакторинг.

1.  **Создать базовый класс Состояния (новый файл `src/entities/states/BaseState.js`)**:
    *   Определяет интерфейс для всех состояний.
    *   **Методы**:
        *   `enter(shina, task)`: Вызывается при входе в состояние. Может принимать `task`, который стал причиной входа.
        *   `execute(shina)`: Вызывается в каждом кадре `update`. Здесь будет логика состояния (например, проверка времени сна).
        *   `exit(shina)`: Вызывается при выходе из состояния.
        *   `onMessage(shina, message)`: Возвращает `true`, если СМС можно обработать.
        *   `onPhoneCall(shina, call)`: Возвращает `true`, если на звонок можно ответить.

2.  **Создать конкретные классы состояний (в `src/entities/states/`)**:
    *   `SleepingState.js`: `onMessage` и `onPhoneCall` всегда возвращают `false`.
    *   `DrivingState.js`: `onMessage` возвращает `true` (можно посмотреть на светофоре), `onPhoneCall` — `false`.
    *   `IdleState.js` (обобщенное состояние "свободен", неважно где): `onMessage` и `onPhoneCall` всегда возвращают `true`.
    *   `BusyState.js` (обобщенное состояние "занят", будь то работа или встреча с родственниками): `onMessage` и `onPhoneCall` возвращают `false`.
    *   `AtRedberryState.js`: Состояние встречи с друзьями. `onMessage/onPhoneCall` возвращают `false`. В методе `exit()` **обязательно** обнуляет `shina.friendshipPriority` до стартового значения из `CONFIG`.

3.  **Модифицировать `Shina.js`**:
    *   Заменить `this.currentState = 'available'` на `this.stateMachine = new StateMachine(this, new IdleState())`. (Предполагается создание простого класса `StateMachine` для управления переходами).
    *   В `update()` вызывать `this.stateMachine.update()`.
    *   В `receiveMessage()` и `receivePhoneCall()` (новый метод) делегировать вызовы `this.stateMachine.currentState.onMessage()` и `this.stateMachine.currentState.onPhoneCall()`.

**1.2. Реализация Системы Приоритетов (в `Shina.js`)**

Эта система будет динамически управлять "желаниями" Шины.

1.  **Добавить свойства в `Shina.js`**: `friendshipPriority`, `fatigueLevel`.
2.  **В методе `_updatePriorities(delta)`**: Реализовать логику роста "соскучился" и "усталости", как было описано ранее, используя константы из `CONFIG.BALANCING`.

---

#### **ЭТАП 2: ИГРОВОЙ ЦИКЛ - ДИНАМИЧЕСКАЯ СИСТЕМА ЗАДАЧ И РАСПИСАНИЯ**

**Цель:** Создать гибкую систему управления расписанием, которая может изменяться в реальном времени. Это позволит добавлять встречи с друзьями и другие внеплановые события.

**Детали реализации:**

**2.1. Улучшение сущности `Task`**

Модифицируем класс `Task` (`src/game/Task.js`), чтобы он содержал всю необходимую информацию для планировщика.

*   **Новые/измененные свойства**:
    *   `endTime`: `Date` (будет вычисляться как `startTime + duration`). Крайне важно для поиска свободных "окон".
    *   `isMeeting`: `boolean` (флаг, чтобы отличать встречи с друзьями).
    *   `dynamicPriority`: `number` (будет использоваться для встреч с друзьями, чтобы его можно было сравнивать с `basePriority` других задач).

**2.2. Создание динамического `ScheduleManager`**

Это будет не просто генератор, а полноценный менеджер текущего дня.

1.  **Создать класс `ScheduleManager` (новый файл `src/game/ScheduleManager.js`)**:
    *   **Свойства**: `this.dailyTasks = []` — отсортированный по `startTime` список задач на *текущий* день.
    *   **Метод `generateDailySchedule(gameDate)`**:
        *   Вызывается каждый день в 00:00.
        *   Генерирует базовый набор задач на день (сон, работа, случайные дела) и заполняет `this.dailyTasks`.
    *   **Ключевой метод `addTask(task)`**:
        *   Принимает новый объект `Task`.
        *   Вставляет его в массив `this.dailyTasks`, сохраняя сортировку по `startTime`.
        *   Этот метод позволит `DecisionEngine` или другим системам (в будущем "Алина") добавлять новые дела в расписание Шины в любой момент.
    *   **Метод `getUpcomingTask()`**: Возвращает первую задачу из `dailyTasks`, у которой статус не `COMPLETED` или `CANCELLED`.
    *   **Метод `findFreeTimeSlot(requestedDate, durationHours)`**:
        *   Ищет в `dailyTasks` на указанный день "окно" достаточной длительности.
        *   **Алгоритм**:
            1.  Сортирует задачи по `startTime`.
            2.  Проверяет интервал от начала дня до первой задачи.
            3.  В цикле проверяет интервал между `task[i].endTime` и `task[i+1].startTime`.
            4.  Проверяет интервал от последней задачи до конца дня.
            5.  Если находит подходящее окно, возвращает `startTime` для новой встречи. Иначе `null`.

**2.3. Интеграция в игровой цикл (`Game.js` и `Shina.js`)**

1.  **В `Game.js`**:
    *   Создать `this.scheduleManager = new ScheduleManager()`.
    *   В `update()` проверять, не наступил ли новый день (`this.timeManager.getGameTime()`). Если да, вызывать `this.scheduleManager.generateDailySchedule()`.
    *   Передавать `this.scheduleManager` в `shinaEntity.updateAI()`.

2.  **В `Shina.js` (метод `updateAI(scheduleManager)`)**:
    *   Получить `const upcomingTask = scheduleManager.getUpcomingTask()`.
    *   Сравнить `upcomingTask` с текущей задачей Шины (`this.currentTask`).
    *   Если задачи отличаются, инициировать смену состояния. Например, если `upcomingTask` — это "Работа", а текущее состояние `IdleState`, то Шина должен начать движение к работе.
    *   Когда Шина прибывает в локацию, он помечает `this.currentTask.status = 'IN_PROGRESS'`. По завершении — `COMPLETED`.

***

Этот детальный план для первой половины разработки закладывает архитектурно правильный и расширяемый фундамент. Мы четко отделили данные (config), поведение (State Machine), планирование (ScheduleManager) и сущности (Task). Следующим шагом будет реализация систем общения и принятия решений поверх этой прочной основы.
